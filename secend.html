<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Snake Arcade MVP</title>
    <meta name="description" content="Minimal Viable Product of a Snake Arcade game built using vanilla JS, HTML, and CSS.">
    <!-- 
        README: This is a self-contained single-file Snake game MVP.
        To run: Save this content as index.html and open it in any modern browser.
        The game uses vanilla JS and draws shapes directly onto the canvas. 
    -->
    <style>
        /* General Reset and Layout */
        :root {
            --color-bg-main: #f0f0f0;
            --color-bg-secondary: #ffffff;
            --color-text: #333333;
            --color-accent: #4CAF50;
            --color-snake: #008000;
            --color-apple: #ff0000;
            --color-grid-line: #e0e0e0;
            --font-family: 'Arial', sans-serif;
            --canvas-border-color: var(--color-accent);
        }

        /* --- Theme: Dark --- */
        .theme-dark {
            --color-bg-main: #1e1e1e;
            --color-bg-secondary: #252526;
            --color-text: #ffffff;
            --color-accent: #00BCD4;
            --color-snake: #00ff00;
            --color-apple: #f39c12;
            --color-grid-line: #333;
            --canvas-border-color: var(--color-accent);
        }

        /* --- Theme: Retro --- */
        .theme-retro {
            --color-bg-main: #d3d3b7;
            --color-bg-secondary: #c0c0a8;
            --color-text: #000000;
            --color-accent: #8b4513;
            --color-snake: #556b2f;
            --color-apple: #a52a2a;
            --color-grid-line: #b0b098;
            --font-family: 'Courier New', monospace;
            --canvas-border-color: var(--color-accent);
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-bg-main);
            color: var(--color-text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #game-container {
            display: flex;
            gap: 20px;
            max-width: 960px;
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Canvas and Main Area */
        #main-area {
            flex-grow: 1;
            position: relative;
            width: 600px; /* Fixed width for desktop layout */
        }

        #game-canvas {
            width: 600px;
            height: 530px;
            background-color: #000;
            display: block;
            border: 2px solid var(--canvas-border-color);
        }

        /* Sidebar/HUD */
        #sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .hud-section {
            background-color: var(--color-bg-main);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--color-grid-line);
        }

        .hud-section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: var(--color-accent);
            border-bottom: 1px solid var(--color-grid-line);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .score-display, .timer-display {
            display: flex;
            justify-content: space-between;
            font-size: 1.2em;
            padding: 4px 0;
        }

        .score-value {
            font-weight: bold;
            color: var(--color-apple);
        }

        /* Controls/Buttons */
        #controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .control-button {
            padding: 10px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: var(--color-accent);
            color: var(--color-bg-secondary);
            transition: background-color 0.2s;
            text-transform: uppercase;
        }

        .control-button:hover {
            opacity: 0.9;
        }

        .control-button:focus {
            outline: 2px solid var(--color-apple);
            outline-offset: 1px;
        }

        /* Preview Canvas */
        #preview-canvas {
            width: 300px;
            height: 366px;
            background-color: #111111;
            border: 1px solid var(--color-grid-line);
            display: block;
        }

        /* Settings Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.visible {
            display: flex;
        }

        .modal-content {
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--color-accent);
            padding-bottom: 10px;
        }

        .setting-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--color-grid-line);
            border-radius: 4px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .setting-options {
            display: flex;
            gap: 10px;
        }

        .setting-card {
            flex: 1;
            padding: 10px;
            border: 2px solid transparent;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            background-color: var(--color-bg-main);
            transition: all 0.2s;
        }

        .setting-card:hover {
            opacity: 0.8;
        }

        .setting-card.selected {
            border-color: var(--color-apple);
            box-shadow: 0 0 5px var(--color-apple);
        }

        /* Game Over Overlay */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            text-align: center;
            z-index: 50;
        }

        #game-over-overlay h2 {
            color: var(--color-apple);
            font-size: 1.5em;
        }

        #game-over-overlay p {
            margin: 10px 0;
            font-size: 0.8em;
        }
        
        /* D-Pad for Mobile */
        #dpad {
            display: none; /* Hide by default, shown in media query */
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(3, 50px);
            width: 150px;
            position: fixed;
            bottom: 20px;
            right: 20px;
            opacity: 0.8;
            z-index: 90;
        }

        .dpad-button {
            background-color: var(--color-accent);
            color: var(--color-bg-secondary);
            border: 1px solid var(--color-bg-main);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            cursor: pointer;
            user-select: none;
            border-radius: 4px;
            touch-action: manipulation; /* Improves responsiveness on touch devices */
        }
        #dpad-up { grid-area: 1 / 2 / 2 / 3; }
        #dpad-down { grid-area: 3 / 2 / 4 / 3; }
        #dpad-left { grid-area: 2 / 1 / 3 / 2; }
        #dpad-right { grid-area: 2 / 3 / 3 / 4; }

        @media (max-width: 950px) {
            #game-container {
                flex-direction: column;
                max-width: 640px;
            }
            #sidebar {
                width: 100%;
                order: -1; /* Move sidebar to top */
            }
            #main-area {
                width: 100%;
            }
            #game-canvas {
                width: 100%; 
                height: 530px; /* Keep defined height for ratio consistency */
            }
            #preview-canvas {
                width: 100%;
                height: 250px;
            }
            #dpad {
                display: grid;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <main id="main-area">
        <!-- Canvas container ensures overlay is correctly positioned relative to canvas -->
        <div style="position: relative; width: 100%; height: 530px;">
            <canvas id="game-canvas" width="600" height="530" role="img" aria-label="Main Snake Game Play Area"></canvas>
            <div id="game-over-overlay">
                <h2>GAME OVER</h2>
                <p>Score: <span id="final-score">0</span></p>
                <button class="control-button" onclick="SnakeGame.initGame()" tabindex="0">Play Again</button>
            </div>
        </div>
    </main>

    <aside id="sidebar">
        <div class="hud-section">
            <h3>Statistics</h3>
            <div class="score-display">
                <span>Current Score:</span>
                <span id="current-score" class="score-value" aria-live="polite">0</span>
            </div>
            <div class="score-display">
                <span>Best Score:</span>
                <span id="best-score" class="score-value">0</span>
            </div>
            <div class="timer-display">
                <span>Time Elapsed:</span>
                <span id="game-timer">00:00</span>
            </div>
        </div>

        <div class="hud-section">
            <h3>Controls</h3>
            <div id="controls">
                <button id="play-pause-btn" class="control-button" aria-label="Play or Pause Game" onclick="SnakeGame.togglePlayPause()" tabindex="0">Play</button>
                <button id="settings-btn" class="control-button" aria-label="Open Settings" onclick="SnakeGame.toggleSettings(true)" tabindex="0">Settings</button>
                <button id="mute-btn" class="control-button" aria-label="Toggle Sound Mute" onclick="SnakeGame.toggleMute()" tabindex="0">Mute</button>
                <button id="end-btn" class="control-button" aria-label="End Game and Reset" onclick="SnakeGame.stopGame()" tabindex="0">End Game</button>
            </div>
        </div>

        <div class="hud-section">
            <h3>Preview</h3>
            <canvas id="preview-canvas" width="300" height="366" role="img" aria-label="Game Preview and UI"></canvas>
        </div>
    </aside>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="settings-title" tabindex="-1">
    <div class="modal-content">
        <h2 id="settings-title">Game Settings</h2>

        <div class="setting-group">
            <label>Game Speed (Tick Rate)</label>
            <div class="setting-options" id="setting-speed">
                <div class="setting-card" data-value="low" aria-label="Speed Low (150ms)" tabindex="0">Low (Slow)</div>
                <div class="setting-card selected" data-value="medium" aria-label="Speed Medium (100ms)" tabindex="0">Medium (Standard)</div>
                <div class="setting-card" data-value="high" aria-label="Speed High (60ms)" tabindex="0">High (Fast)</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Grid Size (Tile Pixel Size)</label>
            <div class="setting-options" id="setting-grid">
                <div class="setting-card" data-value="small" aria-label="Small Grid (16px Tiles)" tabindex="0">Small (16px)</div>
                <div class="setting-card selected" data-value="medium" aria-label="Medium Grid (20px Tiles)" tabindex="0">Medium (20px)</div>
                <div class="setting-card" data-value="large" aria-label="Large Grid (24px Tiles)" tabindex="0">Large (24px)</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Color Theme</label>
            <div class="setting-options" id="setting-theme">
                <div class="setting-card selected" data-value="default" aria-label="Default Light Theme" tabindex="0">Default</div>
                <div class="setting-card" data-value="dark" aria-label="Dark Theme" tabindex="0">Dark</div>
                <div class="setting-card" data-value="retro" aria-label="Retro Theme" tabindex="0">Retro</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Asset Type</label>
            <div class="setting-options" id="setting-sprites">
                <!-- Sprites require external assets/loading. Using shapes by default for MVP reliability. -->
                <div class="setting-card selected" data-value="shapes" aria-label="Use Basic Shapes" tabindex="0">Shapes (Reliable)</div>
                <div class="setting-card" data-value="sprites" aria-label="Attempt to use Sprites" tabindex="0">Sprites (Fallback to Shapes)</div>
            </div>
        </div>

        <button class="control-button" onclick="SnakeGame.toggleSettings(false)" style="margin-top: 20px; width: 100%;" tabindex="0">Close Settings</button>
    </div>
</div>

<!-- D-Pad for mobile input -->
<div id="dpad" role="group" aria-label="Mobile Game Controls">
    <button id="dpad-up" class="dpad-button" data-dir="UP" aria-label="Move Up" tabindex="-1">&#x25B2;</button>
    <button id="dpad-left" class="dpad-button" data-dir="LEFT" aria-label="Move Left" tabindex="-1">&#x25C0;</button>
    <div style="grid-area: 2 / 2 / 3 / 3; display: none;"></div>
    <button id="dpad-right" class="dpad-button" data-dir="RIGHT" aria-label="Move Right" tabindex="-1">&#x25B6;</button>
    <button id="dpad-down" class="dpad-button" data-dir="DOWN" aria-label="Move Down" tabindex="-1">&#x25BC;</button>
</div>

<script>
/**
 * SnakeGame MVP Script
 * Encapsulated within an Immediately Invoked Function Expression (IIFE)
 */
const SnakeGame = (function() {
    // --- Configuration Constants ---
    const CANVAS_W = 600;
    const CANVAS_H = 530;
    const TILE_SIZES = {
        small: 16,
        medium: 20,
        large: 24
    };
    const SPEED_RATES = {
        low: 150,    // ms per tick
        medium: 100, // ms per tick
        high: 60     // ms per tick
    };
    const STORAGE_KEY = 'snakeArcadeBestScore';
    const SETTINGS_KEY = 'snakeArcadeSettings';
    
    // --- State Variables ---
    let canvas, ctx;
    let previewCanvas, previewCtx;
    let animationFrameId = null;
    let isGameRunning = false;
    let isMuted = false;
    let startTime = 0;

    // Game state
    let snake; // Array of {x, y} coordinates
    let apple; // {x, y} coordinate
    let score = 0;
    let bestScore = 0;
    let currentDirection = { x: 1, y: 0 }; 
    let directionQueue = []; // For input buffering
    let lastUpdateTime = 0;
    let tickRate = SPEED_RATES.medium; // Current game speed
    let tileSize = TILE_SIZES.medium;
    let gridW = 0; 
    let gridH = 0; 

    // Settings
    let gameSettings = {
        speed: 'medium',
        grid: 'medium',
        theme: 'default',
        spritesEnabled: 'shapes'
    };

    // DOM Elements cache
    const DOM = {};

    // Check for reduced motion preference
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;


    // --- Utility Functions & Persistence ---

    /** Gets the current color variable value from the CSS environment */
    function getColor(variableName) {
        // Fallback for environments where getComputedStyle might be slow or unavailable
        try {
            return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
        } catch(e) {
            // Provide hardcoded fallback for essential colors
            const map = {
                '--color-apple': '#ff0000',
                '--color-snake': '#008000',
                '--color-accent': '#4CAF50',
                '--color-text': '#333333'
            };
            return map[variableName] || '#fff';
        }
    }

    /** Loads and applies stored settings from localStorage */
    function loadSettings() {
        try {
            const storedSettings = localStorage.getItem(SETTINGS_KEY);
            if (storedSettings) {
                const loaded = JSON.parse(storedSettings);
                // Merge loaded settings, ensuring old keys are handled
                gameSettings = { ...gameSettings, ...loaded };
            }
        } catch (e) {
            console.warn("Could not load stored settings.");
        }
        applySettings();
        updateSettingsUI();
    }

    /** Updates DOM to reflect current settings */
    function updateSettingsUI() {
        // Apply Theme to root element
        document.documentElement.className = `theme-${gameSettings.theme}`;

        // Select cards in modal
        ['speed', 'grid', 'theme', 'sprites'].forEach(setting => {
            const container = DOM[`setting-${setting}`];
            if (container) {
                Array.from(container.children).forEach(card => {
                    card.classList.remove('selected');
                    if (card.getAttribute('data-value') === gameSettings[setting]) {
                        card.classList.add('selected');
                    }
                });
            }
        });
    }

    /** Applies configuration settings like tile size and speed */
    function applySettings() {
        tickRate = SPEED_RATES[gameSettings.speed];
        tileSize = TILE_SIZES[gameSettings.grid];

        // Calculate grid dimensions (600x530 fixed canvas size)
        gridW = Math.floor(CANVAS_W / tileSize);
        gridH = Math.floor(CANVAS_H / tileSize);
        
        // Restart initialization if not running, to update snake position relative to new grid
        if (!isGameRunning) {
            initSnake();
            placeApple();
        }
        
        render(); // Redraw immediately to show new theme/grid
    }

    /** Loads best score from localStorage */
    function loadBestScore() {
        try {
            const storedScore = localStorage.getItem(STORAGE_KEY);
            bestScore = storedScore ? parseInt(storedScore, 10) : 0;
            DOM.bestScore.textContent = bestScore;
        } catch (e) {
            bestScore = 0;
        }
    }

    /** Saves current score as best score if applicable */
    function saveBestScore() {
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem(STORAGE_KEY, bestScore);
            DOM.bestScore.textContent = bestScore;
        }
    }


    // --- Game Setup and State Management ---

    /** Initializes snake starting position and length */
    function initSnake() {
        // Start snake in the upper left quadrant
        const startX = Math.floor(gridW / 4);
        const startY = Math.floor(gridH / 4);
        snake = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
        ];
        currentDirection = { x: 1, y: 0 };
        directionQueue = [];
    }

    /** Places the apple on a random cell that is not occupied by the snake */
    function placeApple() {
        const occupied = new Set();
        snake.forEach(segment => occupied.add(`${segment.x},${segment.y}`));

        let newApple = null;
        let attempts = 0;
        const maxAttempts = gridW * gridH;

        while (!newApple && attempts < maxAttempts) {
            const randX = Math.floor(Math.random() * gridW);
            const randY = Math.floor(Math.random() * gridH);
            const positionKey = `${randX},${randY}`;

            if (!occupied.has(positionKey)) {
                newApple = { x: randX, y: randY };
            }
            attempts++;
        }
        apple = newApple;
        if (!apple && score > 0) {
            // Only happens if grid is full
            stopGame(true); 
        }
    }
    
    /** Initializes the game variables and UI elements for a fresh start */
    function initGame() {
        if (isGameRunning) {
            // This is primarily for the 'Play Again' button, so we skip confirmation
        }
        
        // Reset state
        score = 0;
        startTime = 0;
        updateScoreDisplay();
        updateTimerDisplay();
        DOM.gameOverOverlay.style.display = 'none';
        
        initSnake();
        placeApple();
        render(); 
        
        // Ensure we start paused initially, or play if user clicked "Play Again"
        if (DOM.playPauseBtn.textContent === 'Play Again' || DOM.playPauseBtn.textContent === 'Play') {
            pauseGame();
        } else {
            startGame();
        }
    }


    // --- Game Loop Control ---

    /** Starts or resumes the game loop */
    function startGame() {
        if (isGameRunning) return;
        isGameRunning = true;
        DOM.playPauseBtn.textContent = 'Pause';
        
        if (startTime === 0) {
            startTime = Date.now();
        }
        
        DOM.gameOverOverlay.style.display = 'none';
        
        if (!animationFrameId) {
            lastUpdateTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    /** Stops the game (pause) */
    function pauseGame() {
        if (!isGameRunning) return;
        isGameRunning = false;
        DOM.playPauseBtn.textContent = 'Play';
    }

    /** Toggles between play and pause */
    function togglePlayPause() {
        if (isGameRunning) {
            pauseGame();
        } else {
            startGame();
        }
    }

    /** Ends the game definitively (Game Over or intentional end) */
    function stopGame(collision = false) {
        if (!isGameRunning && score > 0 && !collision) return; 

        pauseGame();
        saveBestScore();
        
        if (collision) {
            DOM.finalScore.textContent = score;
            DOM.gameOverOverlay.style.display = 'flex';
        }

        // Reset state variables
        score = 0;
        startTime = 0;
        
        // Reset play button text
        DOM.playPauseBtn.textContent = collision ? 'Play Again' : 'Play';
    }


    // --- Core Game Logic (Fixed Timestep Update) ---

    /** Processes game state, movement, and collisions */
    function update() {
        // 1. Process Input Buffer
        if (directionQueue.length > 0) {
            currentDirection = directionQueue.shift();
        }

        const head = snake[0];
        const nextX = head.x + currentDirection.x;
        const nextY = head.y + currentDirection.y;

        // 2. Collision Detection
        
        // Wall collision
        if (nextX < 0 || nextX >= gridW || nextY < 0 || nextY >= gridH) {
            stopGame(true);
            return;
        }

        // Self collision 
        for (let i = 0; i < snake.length - 1; i++) {
             // Checking against all body parts except the current tail position
            if (nextX === snake[i].x && nextY === snake[i].y) {
                stopGame(true);
                return;
            }
        }

        // 3. Move Snake
        const newHead = { x: nextX, y: nextY };
        snake.unshift(newHead); // Add new head
        
        // 4. Apple Check
        if (apple && nextX === apple.x && nextY === apple.y) {
            score++;
            updateScoreDisplay();
            placeApple();
            // Tail is NOT popped, snake grows
        } else {
            snake.pop(); // Remove tail
        }
    }


    // --- Drawing & Rendering (Variable Timestep) ---

    /** Updates the HUD score display (aria-live polite handles announcement) */
    function updateScoreDisplay() {
        DOM.currentScore.textContent = score;
    }

    /** Updates the HUD timer display */
    function updateTimerDisplay() {
        if (!startTime) {
            DOM.gameTimer.textContent = '00:00';
            return;
        }
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
        const seconds = String(elapsedSeconds % 60).padStart(2, '0');
        DOM.gameTimer.textContent = `${minutes}:${seconds}`;
    }

    /** Draws the game state to the main canvas */
    function render(timestamp) {
        // Ensure canvas width matches current element size for responsive drawing
        const currentCanvasW = canvas.clientWidth;
        const currentCanvasH = canvas.clientHeight;
        
        // Clear canvas
        ctx.fillStyle = '#000000'; 
        ctx.fillRect(0, 0, currentCanvasW, currentCanvasH);

        // Calculate offset (centering the grid if it doesn't perfectly fill)
        const offsetX = (currentCanvasW - (gridW * tileSize)) / 2;
        const offsetY = (currentCanvasH - (gridH * tileSize)) / 2;

        // 1. Draw Apple (using shapes)
        if (apple) {
            ctx.fillStyle = getColor('--color-apple');
            const x = apple.x * tileSize + offsetX;
            const y = apple.y * tileSize + offsetY;
            
            ctx.fillRect(x, y, tileSize, tileSize);
        }

        // 2. Draw Snake (using shapes)
        snake.forEach((segment, index) => {
            ctx.fillStyle = getColor('--color-snake');
            
            const x = segment.x * tileSize + offsetX;
            const y = segment.y * tileSize + offsetY;

            // Draw primary color
            ctx.fillRect(x, y, tileSize, tileSize);
            
            // Draw tile separation/border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.strokeRect(x, y, tileSize, tileSize);

            if (index === 0) {
                // Draw eyes on the head (simple white dots)
                ctx.fillStyle = '#ffffff';
                const eyeSize = tileSize / 5;
                const halfTile = tileSize / 2;
                
                // Determine eye position based on current direction
                if (currentDirection.x !== 0) { // Horizontal movement
                    ctx.fillRect(x + halfTile - eyeSize, y + tileSize / 4 - eyeSize / 2, eyeSize, eyeSize);
                    ctx.fillRect(x + halfTile - eyeSize, y + tileSize * 3 / 4 - eyeSize / 2, eyeSize, eyeSize);
                } else { // Vertical movement
                    ctx.fillRect(x + tileSize / 4 - eyeSize / 2, y + halfTile - eyeSize, eyeSize, eyeSize);
                    ctx.fillRect(x + tileSize * 3 / 4 - eyeSize / 2, y + halfTile - eyeSize, eyeSize, eyeSize);
                }
            }
        });
        
        // 3. Render Preview Canvas
        renderPreview();
    }
    
    /** Renders the secondary UI/Preview canvas */
    function renderPreview() {
        const pW = 300;
        const pH = 366;
        previewCtx.fillStyle = '#111111';
        previewCtx.fillRect(0, 0, pW, pH);

        previewCtx.font = '24px var(--font-family)';
        previewCtx.textAlign = 'center';
        
        const accentColor = getColor('--color-accent');
        
        previewCtx.fillStyle = accentColor;
        previewCtx.fillText("Snake Arcade", pW / 2, 40);
        
        previewCtx.font = '16px var(--font-family)';
        previewCtx.fillStyle = getColor('--color-text'); // Text might be white on dark canvas
        
        let lineY = 80;
        previewCtx.fillText("Controls:", pW / 2, lineY);
        lineY += 25;
        previewCtx.fillText("WASD or Arrows to move.", pW / 2, lineY);
        lineY += 25;
        previewCtx.fillText("Swipe or D-Pad (mobile).", pW / 2, lineY);

        // Draw a miniature snake example
        const miniTS = 15;
        const startX = pW / 2 - (miniTS * 2.5);
        let miniY = 180;
        
        // Snake body
        previewCtx.fillStyle = getColor('--color-snake');
        previewCtx.fillRect(startX, miniY, miniTS * 3, miniTS);
        
        // Apple
        previewCtx.fillStyle = getColor('--color-apple');
        previewCtx.fillRect(startX + miniTS * 4, miniY, miniTS, miniTS);
        
        previewCtx.font = '14px var(--font-family)';
        previewCtx.fillStyle = '#ffffff'; // Ensure text is visible on the dark preview canvas
        previewCtx.fillText("Snake", startX + miniTS * 1.5, miniY + miniTS + 15);
        previewCtx.fillText("Apple", startX + miniTS * 4.5, miniY + miniTS + 15);
    }


    /** The main game loop driven by requestAnimationFrame */
    function gameLoop(timestamp) {
        if (isGameRunning) {
            // If the game has been paused for a long time, reset lastUpdateTime to prevent catch-up surge
            if (timestamp - lastUpdateTime > 500) {
                 lastUpdateTime = timestamp - tickRate;
            }

            const deltaTime = timestamp - lastUpdateTime;

            // Fixed Update Timestep Logic
            if (deltaTime >= tickRate) {
                // If reduced motion is preferred, we only calculate one tick per frame update.
                // Otherwise, calculate multiple ticks to catch up if rendering is slow.
                if (reducedMotion || deltaTime < tickRate * 2) {
                    update();
                    lastUpdateTime += tickRate;
                } else {
                    let updateCount = 0;
                    while (lastUpdateTime < timestamp && updateCount < 3) {
                        update();
                        lastUpdateTime += tickRate;
                        updateCount++;
                    }
                    // If we're still far behind, reset time to prevent physics spiral
                    if (updateCount === 3) {
                        lastUpdateTime = timestamp;
                    }
                }
                
                updateTimerDisplay();
            }
        }
        
        // Variable Render Timestep
        render(timestamp);
        
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // --- Input Handling ---

    /** Processes incoming direction input */
    function handleInput(dirX, dirY) {
        if (!isGameRunning) {
            // Allow starting game with directional keys
            startGame();
        }

        // Determine the direction we need to check against (current, or the last one buffered)
        const lastDir = directionQueue.length > 0 ? directionQueue[directionQueue.length - 1] : currentDirection;
        
        // Prevent 180 degree reversal check
        const isOppositeX = dirX === -lastDir.x && dirX !== 0;
        const isOppositeY = dirY === -lastDir.y && dirY !== 0;
        
        if (isOppositeX || isOppositeY) {
            return;
        }

        // Buffer up to 1 extra move
        if (directionQueue.length < 1) {
            directionQueue.push({ x: dirX, y: dirY });
        }
    }
    
    /** Keyboard event listener */
    function handleKeyDown(event) {
        const key = event.key.toLowerCase();
        let x = 0, y = 0;

        switch (key) {
            case 'arrowup':
            case 'w': y = -1; break;
            case 'arrowdown':
            case 's': y = 1; break;
            case 'arrowleft':
            case 'a': x = -1; break;
            case 'arrowright':
            case 'd': x = 1; break;
            case ' ':
                event.preventDefault(); 
                togglePlayPause();
                return;
            default: return;
        }
        event.preventDefault(); 
        handleInput(x, y);
    }
    
    // Touch/Swipe Logic
    let touchStartX, touchStartY;
    const swipeThreshold = 30; // Reduced threshold for reliability

    function handleTouchStart(event) {
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            event.preventDefault(); // Prevent scrolling on touch start
        }
    }

    function handleTouchEnd(event) {
        if (!touchStartX) return;
        
        const touch = event.changedTouches[0];
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        
        if (Math.abs(dx) > swipeThreshold || Math.abs(dy) > swipeThreshold) {
            let dirX = 0, dirY = 0;
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                dirX = dx > 0 ? 1 : -1;
            } else {
                // Vertical swipe
                dirY = dy > 0 ? 1 : -1;
            }
            handleInput(dirX, dirY);
        }
        touchStartX = null;
        touchStartY = null;
    }

    // D-Pad handler uses the same logic as handleInput
    function handleDpadClick(event) {
        const dir = event.currentTarget.getAttribute('data-dir');
        let x = 0, y = 0;
        switch (dir) {
            case 'UP': y = -1; break;
            case 'DOWN': y = 1; break;
            case 'LEFT': x = -1; break;
            case 'RIGHT': x = 1; break;
        }
        handleInput(x, y);
    }

    // Settings Card Handler
    function handleSettingClick(event) {
        const card = event.currentTarget;
        const group = card.parentElement.id.replace('setting-', '');
        const value = card.getAttribute('data-value');

        gameSettings[group] = value;
        updateSettingsUI();
        applySettings();
        
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
    }

    /** Toggles the visibility of the settings modal */
    function toggleSettings(visible) {
        if (visible) {
            DOM.settingsModal.classList.add('visible');
            pauseGame(); 
            DOM.settingsModal.focus();
        } else {
            DOM.settingsModal.classList.remove('visible');
            // Check if 'Pause' button text indicates we were running before modal opened
            if (DOM.playPauseBtn.textContent === 'Pause') {
                 startGame();
            }
        }
    }

    /** Toggles mute status */
    function toggleMute() {
        isMuted = !isMuted;
        const muteBtn = document.getElementById('mute-btn');
        muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
        muteBtn.setAttribute('aria-label', isMuted ? 'Unmute Sound' : 'Mute Sound');
    }


    // --- Initialization ---
    
    /** Initializes DOM references */
    function initializeDOM() {
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');
        previewCanvas = document.getElementById('preview-canvas');
        previewCtx = previewCanvas.getContext('2d');

        DOM.currentScore = document.getElementById('current-score');
        DOM.bestScore = document.getElementById('best-score');
        DOM.gameTimer = document.getElementById('game-timer');
        DOM.playPauseBtn = document.getElementById('play-pause-btn');
        DOM.gameOverOverlay = document.getElementById('game-over-overlay');
        DOM.finalScore = document.getElementById('final-score');
        
        DOM.settingsModal = document.getElementById('settings-modal');
        DOM.settingSpeed = document.getElementById('setting-speed');
        DOM.settingGrid = document.getElementById('setting-grid');
        DOM.settingTheme = document.getElementById('setting-theme');
        DOM.settingSprites = document.getElementById('setting-sprites');
    }

    /** Sets up all UI and control listeners */
    function setupEventListeners() {
        window.addEventListener('keydown', handleKeyDown);

        // Touch/Swipe controls on main canvas
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        
        // D-Pad listeners
        document.querySelectorAll('#dpad .dpad-button').forEach(button => {
            button.addEventListener('click', handleDpadClick);
        });

        // Settings modal handlers
        document.querySelectorAll('.setting-options .setting-card').forEach(card => {
            card.addEventListener('click', handleSettingClick);
            card.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleSettingClick({ currentTarget: card });
                }
            });
        });
    }

    /** Initializes all game components */
    function init() {
        initializeDOM();
        loadBestScore();
        loadSettings(); 
        
        setupEventListeners();
        
        // Start the loop (will run paused initially)
        lastUpdateTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
        
        initGame(); 
    }

    // Expose public methods
    return {
        init: init,
        startGame: startGame,
        pauseGame: pauseGame,
        stopGame: stopGame,
        togglePlayPause: togglePlayPause,
        toggleSettings: toggleSettings,
        toggleMute: toggleMute,
        initGame: initGame
    };

})();

// Initialize the game when the window loads
window.addEventListener('load', SnakeGame.init);
</script>

</body>
</html>
