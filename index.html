<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Snake ‚Äî Enhanced Playground</title>
<style>
  :root {
    --bg: #f1f4f8;
    --panel: #4a752c;
    --accent: #34a853;
    --muted: #6b7280;
    --card: #e8eef1;
    --canvas-dark: #122116;
    --canvas-light: linear-gradient(#4c7f2f, #2d541e);
    --score-text: #ffffff;
  }
  
  .dark {
    --bg: #0b0f12;
    --panel: #1f2923;
    --accent: #6fd48a;
    --muted: #9aa4a1;
    --card: #1a1d20;
    --canvas-dark: linear-gradient(180deg, #0f2616, #07210f);
    --canvas-light: linear-gradient(120deg, #13311a, #0b2814);
    --score-text: #e8f7ea;
  }

  * { box-sizing: border-box; font-family: Inter, Roboto, Arial, sans-serif; }
  html, body { 
    height: 100%; 
    margin: 0; 
    background: var(--bg); 
    display: flex; 
    align-items: center; 
    justify-content: center;
    overflow: hidden;
    touch-action: none;
  }
  
  .container {
    width: 900px; 
    max-width: 98vw; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
    padding: 12px;
  }
  
  .frame {
    width: 100%;
    max-width: 100%; 
    background: transparent; 
    position: relative; 
    border-radius: 16px; 
    overflow: hidden;
    box-shadow: 0 12px 40px rgba(0,0,0,0.25);
  }
  
  .topbar {
    height: 70px;
    background: var(--panel); 
    width: 100%; 
    border-radius: 16px 16px 0 0; 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    padding: 0 20px; 
    color: var(--score-text);
  }
  
  .left { display: flex; align-items: center; gap: 16px; }
  
  .logoBox {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 22px;
    color: white;
    background: linear-gradient(135deg, #5bb24e, #2f6b24);
    box-shadow: 0 4px 14px rgba(0,0,0,0.3);
  }
  
  .scoreArea { display: flex; flex-direction: column; }
  .score { font-size: 24px; font-weight: 700; }
  .highScore { font-size: 13px; opacity: 0.85; margin-top: 2px; }
  
  .right { display: flex; align-items: center; gap: 10px; }
  
  .iconBtn {
    width: 42px;
    height: 42px;
    border-radius: 10px;
    background: rgba(255,255,255,0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border: none;
    transition: background 0.2s, transform 0.1s;
  }
  .iconBtn:hover { background: rgba(255,255,255,0.22); }
  .iconBtn:active { transform: scale(0.94); }
  
  .boardWrap {
    width: 100%; 
    background: var(--canvas-dark); 
    height: 650px;
    display: flex; 
    align-items: center; 
    justify-content: center; 
    position: relative; 
    border-radius: 0 0 16px 16px; 
    overflow: hidden;
  }
  
  canvas#main {
    background: var(--canvas-light); 
    display: block; 
    border-radius: 6px;
  }
  
  .overlay {
    position: absolute; 
    inset: 0; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(6px);
    transition: opacity 0.3s;
  }
  .overlay.hidden { 
    opacity: 0; 
    pointer-events: none; 
  }
  
  .menuCard {
    width: 380px;
    max-width: 90%;
    background: linear-gradient(180deg, #4dc1f9, #2f9bd6); 
    border-radius: 20px; 
    text-align: center; 
    display: flex; 
    flex-direction: column;
    align-items: center; 
    padding: 32px; 
    gap: 18px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    transform: scale(1);
    transition: transform 0.3s cubic-bezier(0.2, 0.9, 0.2, 1), opacity 0.3s;
  }
  .menuCard.exit { transform: scale(0.9); opacity: 0; }
  .menuCard h2 { margin: 0; color: #fff; font-size: 38px; text-shadow: 0 3px 10px rgba(0,0,0,0.3); }
  .menuCard .subtitle { color: #e8f8ff; font-size: 15px; margin-top: -4px; }
  
  .bigBtn {
    width: 100%;
    background: linear-gradient(135deg, #0ea5e9, #0284c7);
    border: none;
    color: #fff;
    padding: 16px 24px;
    border-radius: 14px;
    cursor: pointer;
    font-size: 20px;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    transition: transform 0.15s, box-shadow 0.25s;
  }
  .bigBtn:hover { transform: translateY(-3px); box-shadow: 0 10px 28px rgba(0,0,0,0.4); }
  .bigBtn:active { transform: translateY(-1px); }
  
  .instructions {
    color: white;
    font-size: 13px;
    opacity: 0.92;
    line-height: 1.6;
  }
  
  .settingsPanel {
    position: absolute; 
    right: 14px; 
    top: 85px; 
    width: 320px;
    max-width: calc(100% - 28px);
    background: var(--card); 
    border-radius: 14px; 
    padding: 20px; 
    box-shadow: 0 10px 40px rgba(0,0,0,0.35); 
    color: var(--muted); 
    z-index: 50;
    transform: translateY(-12px);
    opacity: 0;
    pointer-events: none;
    transition: transform 0.25s, opacity 0.25s;
  }
  .settingsPanel.open {
    transform: translateY(0);
    opacity: 1;
    pointer-events: auto;
  }
  
  .settingsTitle { font-weight: 700; margin-bottom: 14px; color: var(--score-text); font-size: 17px; }
  .dark .settingsTitle { color: var(--accent); }
  
  .optRow { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; }
  .optLabel { font-size: 14px; font-weight: 500; }
  
  .picker { display: flex; gap: 8px; }
  
  .chip {
    padding: 8px 12px;
    border-radius: 9px;
    background: rgba(0,0,0,0.08);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s;
    border: 2px solid transparent;
  }
  .dark .chip { background: rgba(255,255,255,0.08); }
  .chip:hover { background: rgba(0,0,0,0.14); transform: translateY(-1px); }
  .dark .chip:hover { background: rgba(255,255,255,0.14); }
  .chip.active { 
    background: var(--accent); 
    color: white; 
    box-shadow: 0 4px 14px rgba(0,0,0,0.2);
    transform: scale(1.05);
  }
  
  .gameOverCard {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.75);
    backdrop-filter: blur(8px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .gameOverCard.show { opacity: 1; pointer-events: auto; }
  
  .goInner {
    background: linear-gradient(180deg, #ef4444, #dc2626);
    color: #fff;
    padding: 36px 40px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    transform: scale(0.9);
    transition: transform 0.3s;
  }
  .gameOverCard.show .goInner { transform: scale(1); }
  .goTitle { font-size: 34px; font-weight: 700; margin-bottom: 12px; }
  .goScore { font-size: 18px; margin-bottom: 6px; }
  .goHigh { font-size: 14px; opacity: 0.88; margin-bottom: 20px; }
  .goBtns { display: flex; gap: 12px; justify-content: center; }
  .goBtn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    padding: 14px 28px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 600;
    transition: background 0.2s, transform 0.1s;
  }
  .goBtn:hover { background: rgba(255,255,255,0.3); transform: translateY(-2px); }
  .goBtn:active { transform: translateY(0); }
  .goBtn.primary { background: white; color: #dc2626; }
  .goBtn.primary:hover { background: #f5f5f5; }
  
  .pauseOverlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(6px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s;
  }
  .pauseOverlay.show { opacity: 1; pointer-events: auto; }
  .pauseText {
    color: white;
    font-size: 40px;
    font-weight: 700;
    text-shadow: 0 5px 20px rgba(0,0,0,0.5);
  }
  
  .bottomBar {
    width: 100%; 
    display: flex; 
    gap: 10px; 
    justify-content: space-between; 
    align-items: center;
    flex-wrap: wrap;
  }
  
  .controlBtns { display: flex; gap: 10px; }
  
  .toggle {
    background: var(--card);
    color: var(--muted);
    padding: 12px 18px;
    border-radius: 12px;
    cursor: pointer;
    border: none;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
  }
  .toggle:hover { background: var(--accent); color: white; transform: translateY(-1px); }
  .toggle:active { transform: translateY(0); }
  .toggle.active { background: var(--accent); color: white; }
  
  .mobileHint {
    color: var(--muted);
    font-size: 12px;
    text-align: right;
  }
  
  .eatPopup {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 24px;
    color: #fff;
    font-weight: 700;
    font-size: 22px;
    padding: 10px 18px;
    border-radius: 12px;
    background: rgba(0,0,0,0.7);
    pointer-events: none;
    opacity: 0;
    transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.6s;
  }

  @media (max-width: 900px) {
    .container { padding: 8px; gap: 10px; }
    .frame { border-radius: 12px; }
    .topbar { height: 60px; padding: 0 16px; border-radius: 12px 12px 0 0; }
    .logoBox { width: 40px; height: 40px; font-size: 18px; }
    .score { font-size: 20px; }
    .boardWrap { height: 500px; border-radius: 0 0 12px 12px; }
    .menuCard { padding: 24px; gap: 14px; }
    .menuCard h2 { font-size: 30px; }
    .bigBtn { padding: 14px 20px; font-size: 17px; }
    .settingsPanel { width: calc(100% - 24px); right: 12px; }
    .goInner { padding: 28px 32px; }
    .goTitle { font-size: 28px; }
    .bottomBar { flex-direction: column; gap: 10px; }
    .mobileHint { text-align: center; }
  }
  
  @media (max-height: 700px) {
    .boardWrap { height: 420px; }
    .menuCard { padding: 20px; gap: 12px; }
    .topbar { height: 56px; }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="frame" id="frame">
      <div class="topbar">
        <div class="left">
          <div class="logoBox">üêç</div>
          <div class="scoreArea">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="highScore">Best: <span id="highScore">0</span></div>
          </div>
        </div>
        <div class="right">
          <button class="iconBtn" id="themeToggle" title="Toggle theme">
            <svg id="themeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2">
              <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
            </svg>
          </button>
          <button class="iconBtn" id="settingsBtn" title="Settings">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/>
            </svg>
          </button>
        </div>
      </div>

      <div class="boardWrap">
        <canvas id="main"></canvas>

        <div class="overlay" id="overlay">
          <div class="menuCard" id="menuCard">
            <h2>üêç Snake</h2>
            <div class="subtitle">Classic arcade game ‚Äî smooth & fun!</div>
            <button class="bigBtn" id="playBtn">‚ñ∂ Play Game</button>
            <div class="instructions">
              <strong>Controls:</strong> Arrow keys or WASD<br>
              <strong>Mobile:</strong> Swipe to move<br>
              <strong>Tip:</strong> Golden apples give +3 points! ‚ú®
            </div>
          </div>
        </div>

        <div class="settingsPanel" id="settings">
          <div class="settingsTitle">‚öôÔ∏è Settings</div>
          <div class="optRow">
            <div class="optLabel">Speed</div>
            <div class="picker" id="speedPicker">
              <div class="chip" data-speed="0">Slow</div>
              <div class="chip active" data-speed="1">Normal</div>
              <div class="chip" data-speed="2">Fast</div>
            </div>
          </div>
          <div class="optRow">
            <div class="optLabel">Grid Size</div>
            <div class="picker" id="sizePicker">
              <div class="chip" data-size="15">Small</div>
              <div class="chip active" data-size="18">Normal</div>
              <div class="chip" data-size="22">Large</div>
            </div>
          </div>
          <div class="optRow">
            <div class="optLabel">Wall Mode</div>
            <div class="picker" id="wrapPicker">
              <div class="chip active" data-wrap="true">Wrap</div>
              <div class="chip" data-wrap="false">Solid</div>
            </div>
          </div>
        </div>

        <div class="gameOverCard" id="gameOver">
          <div class="goInner">
            <div class="goTitle">üíÄ Game Over</div>
            <div class="goScore">Score: <span id="finalScore">0</span></div>
            <div class="goHigh">Best: <span id="finalHigh">0</span></div>
            <div class="goBtns">
              <button class="goBtn primary" id="retryBtn">Play Again</button>
              <button class="goBtn" id="menuBtn">Menu</button>
            </div>
          </div>
        </div>

        <div class="pauseOverlay" id="pauseOverlay">
          <div class="pauseText">‚è∏Ô∏è PAUSED</div>
        </div>

        <div id="eatPopup" class="eatPopup">+1</div>
      </div>
    </div>

    <div class="bottomBar">
      <div class="controlBtns">
        <button class="toggle" id="pauseBtn">‚è∏Ô∏è Pause</button>
      </div>
      <div class="mobileHint">Swipe on canvas to control ‚Ä¢ Press P to pause</div>
    </div>
  </div>

<script>
(function() {
  'use strict';

  // DOM Elements
  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const menuCard = document.getElementById('menuCard');
  const playBtn = document.getElementById('playBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settings');
  const speedPicker = document.getElementById('speedPicker');
  const sizePicker = document.getElementById('sizePicker');
  const wrapPicker = document.getElementById('wrapPicker');
  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('highScore');
  const gameOverEl = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const finalHighEl = document.getElementById('finalHigh');
  const retryBtn = document.getElementById('retryBtn');
  const menuBtn = document.getElementById('menuBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const themeToggle = document.getElementById('themeToggle');
  const eatPopup = document.getElementById('eatPopup');
  const boardWrap = document.querySelector('.boardWrap');

  // Game Configuration
  const CONFIG = {
    speeds: [7, 11, 16],
    gridSizes: [15, 18, 22],
    goldenAppleChance: 0.15,
    goldenAppleScore: 3,
    normalAppleScore: 1
  };

  // Game State
  let state = {
    cols: 18,
    rows: 18,
    cellSize: 32,
    speedLevel: 1,
    wrap: true,
    running: false,
    paused: false,
    gameOver: false,
    score: 0,
    highScore: 0,
    snake: [],
    direction: { x: 1, y: 0 },
    nextDirection: null,
    apple: null,
    lastMoveTime: 0,
    moveInterval: 100,
    particles: []
  };

  // Load high score
  try {
    state.highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
    highScoreEl.textContent = state.highScore;
  } catch (e) {}

  // Canvas Setup
  function setupCanvas() {
    const container = boardWrap;
    const maxWidth = Math.min(container.clientWidth - 30, 800);
    const maxHeight = container.clientHeight - 30;
    
    state.cellSize = Math.floor(Math.min(maxWidth, maxHeight) / state.cols);
    state.cellSize = Math.max(state.cellSize, 20);
    state.rows = Math.floor(maxHeight / state.cellSize);
    
    // Ensure minimum rows
    state.rows = Math.max(state.rows, 12);
    
    const width = state.cols * state.cellSize;
    const height = state.rows * state.cellSize;
    
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  // Initialize Game
  function initGame() {
    setupCanvas();
    
    const centerX = Math.floor(state.cols / 2);
    const centerY = Math.floor(state.rows / 2);
    
    state.snake = [
      { x: centerX - 2, y: centerY },
      { x: centerX - 1, y: centerY },
      { x: centerX, y: centerY }
    ];
    
    state.direction = { x: 1, y: 0 };
    state.nextDirection = null;
    state.score = 0;
    state.gameOver = false;
    state.paused = false;
    state.particles = [];
    state.lastMoveTime = performance.now();
    state.moveInterval = 1000 / CONFIG.speeds[state.speedLevel];
    
    updateScore();
    placeApple();
  }

  // Place Apple
  function placeApple() {
    const occupied = new Set(state.snake.map(s => `${s.x},${s.y}`));
    const free = [];
    
    for (let y = 0; y < state.rows; y++) {
      for (let x = 0; x < state.cols; x++) {
        if (!occupied.has(`${x},${y}`)) {
          free.push({ x, y });
        }
      }
    }
    
    if (free.length === 0) {
      // Player won!
      state.gameOver = true;
      showGameOver();
      return;
    }
    
    const pos = free[Math.floor(Math.random() * free.length)];
    state.apple = {
      x: pos.x,
      y: pos.y,
      isGolden: Math.random() < CONFIG.goldenAppleChance
    };
  }

  // Update Score
  function updateScore() {
    scoreEl.textContent = state.score;
    
    if (state.score > state.highScore) {
      state.highScore = state.score;
      highScoreEl.textContent = state.highScore;
      try {
        localStorage.setItem('snakeHighScore', state.highScore);
      } catch (e) {}
    }
  }

  // Show Eat Popup
  function showEatPopup(points, isGolden) {
    eatPopup.textContent = isGolden ? `+${points} ‚ú®` : `+${points}`;
    eatPopup.style.background = isGolden ? 'linear-gradient(135deg, #fbbf24, #f59e0b)' : 'rgba(0,0,0,0.7)';
    eatPopup.style.opacity = '1';
    eatPopup.style.transform = 'translateX(-50%) translateY(0)';
    
    requestAnimationFrame(() => {
      eatPopup.style.transform = 'translateX(-50%) translateY(-40px)';
      eatPopup.style.opacity = '0';
    });
  }

  // Spawn Particles
  function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1.5 + Math.random() * 2.5;
      state.particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        color: color,
        size: 3 + Math.random() * 4
      });
    }
  }

  // Game Tick
  function gameTick() {
    if (!state.running || state.paused || state.gameOver) return;
    
    // Apply queued direction
    if (state.nextDirection) {
      const isOpposite = 
        state.nextDirection.x === -state.direction.x && 
        state.nextDirection.y === -state.direction.y;
      
      if (!isOpposite) {
        state.direction = state.nextDirection;
      }
      state.nextDirection = null;
    }
    
    // Calculate new head position
    const head = state.snake[state.snake.length - 1];
    let newX = head.x + state.direction.x;
    let newY = head.y + state.direction.y;
    
    // Handle wrapping or wall collision
    if (state.wrap) {
      if (newX < 0) newX = state.cols - 1;
      if (newX >= state.cols) newX = 0;
      if (newY < 0) newY = state.rows - 1;
      if (newY >= state.rows) newY = 0;
    } else {
      if (newX < 0 || newX >= state.cols || newY < 0 || newY >= state.rows) {
        handleDeath();
        return;
      }
    }
    
    // Check self-collision
    for (let i = 0; i < state.snake.length - 1; i++) {
      if (state.snake[i].x === newX && state.snake[i].y === newY) {
        handleDeath();
        return;
      }
    }
    
    // Move snake
    state.snake.push({ x: newX, y: newY });
    
    // Check apple collision
    if (state.apple && newX === state.apple.x && newY === state.apple.y) {
      const points = state.apple.isGolden ? CONFIG.goldenAppleScore : CONFIG.normalAppleScore;
      state.score += points;
      updateScore();
      
      // Visual feedback
      const px = state.apple.x * state.cellSize + state.cellSize / 2;
      const py = state.apple.y * state.cellSize + state.cellSize / 2;
      spawnParticles(px, py, state.apple.isGolden ? '#fbbf24' : '#ef4444', state.apple.isGolden ? 25 : 15);
      showEatPopup(points, state.apple.isGolden);
      
      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate(state.apple.isGolden ? [30, 20, 30] : 25);
      }
      
      placeApple();
      
      // Speed up slightly
      state.moveInterval = Math.max(50, 1000 / (CONFIG.speeds[state.speedLevel] + Math.floor(state.score / 5) * 0.5));
    } else {
      state.snake.shift();
    }
  }

  // Handle Death
  function handleDeath() {
    state.gameOver = true;
    state.running = false;
    
    // Haptic feedback
    if (navigator.vibrate) {
      navigator.vibrate([100, 50, 100]);
    }
    
    showGameOver();
  }

  // Show Game Over
  function showGameOver() {
    finalScoreEl.textContent = state.score;
    finalHighEl.textContent = state.highScore;
    gameOverEl.classList.add('show');
  }

  // Hide Game Over
  function hideGameOver() {
    gameOverEl.classList.remove('show');
  }

  // Set Direction
  function setDirection(dx, dy) {
    if (!state.running || state.paused || state.gameOver) return;
    
    // Prevent 180-degree turns
    const isOpposite = dx === -state.direction.x && dy === -state.direction.y;
    if (isOpposite) return;
    
    // Prevent setting same direction
    if (dx === state.direction.x && dy === state.direction.y) return;
    
    state.nextDirection = { x: dx, y: dy };
  }

  // Drawing Functions
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const isDark = document.documentElement.classList.contains('dark');
    
    // Draw grid
    for (let y = 0; y < state.rows; y++) {
      for (let x = 0; x < state.cols; x++) {
        const isEven = (x + y) % 2 === 0;
        ctx.fillStyle = isDark 
          ? (isEven ? '#0f3216' : '#0a2610')
          : (isEven ? '#4b7730' : '#3d6426');
        ctx.fillRect(x * state.cellSize, y * state.cellSize, state.cellSize, state.cellSize);
      }
    }
    
    // Draw apple
    if (state.apple) {
      const ax = state.apple.x * state.cellSize + state.cellSize / 2;
      const ay = state.apple.y * state.cellSize + state.cellSize / 2;
      const radius = state.cellSize * 0.4;
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(ax, ay + radius * 0.6, radius * 0.85, radius * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Apple
      if (state.apple.isGolden) {
        const grad = ctx.createRadialGradient(ax - 5, ay - 5, 0, ax, ay, radius);
        grad.addColorStop(0, '#fde047');
        grad.addColorStop(1, '#f59e0b');
        ctx.fillStyle = grad;
      } else {
        const grad = ctx.createRadialGradient(ax - 5, ay - 5, 0, ax, ay, radius);
        grad.addColorStop(0, '#f87171');
        grad.addColorStop(1, '#dc2626');
        ctx.fillStyle = grad;
      }
      
      ctx.beginPath();
      ctx.arc(ax, ay, radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Shine
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.beginPath();
      ctx.arc(ax - radius * 0.35, ay - radius * 0.35, radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw snake
    for (let i = 0; i < state.snake.length; i++) {
      const seg = state.snake[i];
      const isHead = i === state.snake.length - 1;
      const t = i / Math.max(1, state.snake.length - 1);
      
      const x = seg.x * state.cellSize;
      const y = seg.y * state.cellSize;
      const padding = state.cellSize * 0.08;
      const size = state.cellSize - padding * 2;
      const cornerRadius = size * 0.28;
      
      // Snake color gradient
      let r, g, b;
      if (isDark) {
        r = Math.floor(125 + 65 * t);
        g = Math.floor(205 + 40 * (1 - t));
        b = Math.floor(145 + 65 * t);
      } else {
        r = Math.floor(40 + 22 * t);
        g = Math.floor(145 + 42 * (1 - t));
        b = Math.floor(52 + 22 * t);
      }
      
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      
      // Draw rounded rectangle
      ctx.beginPath();
      ctx.roundRect(x + padding, y + padding, size, size, cornerRadius);
      ctx.fill();
      
      // Draw eyes on head
      if (isHead) {
        const eyeSize = state.cellSize * 0.14;
        const eyeOffset = state.cellSize * 0.2;
        
        ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
        
        // Position eyes based on direction
        let eye1X = x + state.cellSize / 2 - eyeOffset;
        let eye1Y = y + state.cellSize / 2 - eyeOffset * 0.5;
        let eye2X = x + state.cellSize / 2 + eyeOffset;
        let eye2Y = y + state.cellSize / 2 - eyeOffset * 0.5;
        
        if (state.direction.x === -1) {
          eye1X = x + state.cellSize * 0.3;
          eye2X = x + state.cellSize * 0.3;
          eye1Y = y + state.cellSize * 0.35;
          eye2Y = y + state.cellSize * 0.65;
        } else if (state.direction.x === 1) {
          eye1X = x + state.cellSize * 0.7;
          eye2X = x + state.cellSize * 0.7;
          eye1Y = y + state.cellSize * 0.35;
          eye2Y = y + state.cellSize * 0.65;
        } else if (state.direction.y === -1) {
          eye1Y = y + state.cellSize * 0.3;
          eye2Y = y + state.cellSize * 0.3;
        } else if (state.direction.y === 1) {
          eye1Y = y + state.cellSize * 0.7;
          eye2Y = y + state.cellSize * 0.7;
        }
        
        ctx.beginPath();
        ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
        ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Draw particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Update Particles
  function updateParticles(dt) {
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12; // Gravity
      p.life -= dt * 0.0018;
      
      if (p.life <= 0) {
        state.particles.splice(i, 1);
      }
    }
  }

  // Main Game Loop
  let lastTime = 0;
  
  function gameLoop(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;
    
    if (state.running && !state.paused && !state.gameOver) {
      const now = performance.now();
      if (now - state.lastMoveTime >= state.moveInterval) {
        gameTick();
        state.lastMoveTime = now;
      }
    }
    
    updateParticles(dt);
    draw();
    
    requestAnimationFrame(gameLoop);
  }

  // Start Game
  function startGame() {
    initGame();
    state.running = true;
    state.lastMoveTime = performance.now();
    overlay.classList.add('hidden');
    hideGameOver();
    pauseOverlay.classList.remove('show');
    pauseBtn.textContent = '‚è∏Ô∏è Pause';
  }

  // Show Menu
  function showMenu() {
    state.running = false;
    state.paused = false;
    overlay.classList.remove('hidden');
    hideGameOver();
    pauseOverlay.classList.remove('show');
  }

  // Toggle Pause
  function togglePause() {
    if (!state.running || state.gameOver) return;
    
    state.paused = !state.paused;
    pauseOverlay.classList.toggle('show', state.paused);
    pauseBtn.textContent = state.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    
    if (!state.paused) {
      state.lastMoveTime = performance.now();
    }
  }

  // Input Handlers
  document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    
    if (key === 'p' || key === 'escape') {
      e.preventDefault();
      togglePause();
      return;
    }
    
    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
      e.preventDefault();
      
      if (key === 'arrowup' || key === 'w') setDirection(0, -1);
      else if (key === 'arrowdown' || key === 's') setDirection(0, 1);
      else if (key === 'arrowleft' || key === 'a') setDirection(-1, 0);
      else if (key === 'arrowright' || key === 'd') setDirection(1, 0);
    }
    
    // Start game with space or enter
    if ((key === ' ' || key === 'enter') && !state.running) {
      e.preventDefault();
      startGame();
    }
  });

  // Touch Controls
  let touchStart = null;
  const SWIPE_THRESHOLD = 25;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length === 1) {
      touchStart = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (!touchStart) return;
    
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStart.x;
    const dy = touch.clientY - touchStart.y;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    
    if (Math.max(adx, ady) >= SWIPE_THRESHOLD) {
      if (adx > ady) {
        setDirection(dx > 0 ? 1 : -1, 0);
      } else {
        setDirection(0, dy > 0 ? 1 : -1);
      }
    }
    
    touchStart = null;
  }, { passive: false });

  // UI Event Listeners
  playBtn.addEventListener('click', startGame);
  retryBtn.addEventListener('click', startGame);
  menuBtn.addEventListener('click', showMenu);
  pauseBtn.addEventListener('click', togglePause);

  settingsBtn.addEventListener('click', () => {
    settingsPanel.classList.toggle('open');
  });

  // Close settings when clicking outside
  document.addEventListener('click', (e) => {
    if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
      settingsPanel.classList.remove('open');
    }
  });

  // Speed Picker
  speedPicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    
    speedPicker.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    state.speedLevel = parseInt(chip.dataset.speed);
    state.moveInterval = 1000 / CONFIG.speeds[state.speedLevel];
  });

  // Size Picker
  sizePicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    
    sizePicker.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    state.cols = parseInt(chip.dataset.size);
    
    if (state.running) {
      startGame();
    } else {
      setupCanvas();
    }
  });

  // Wrap Picker
  wrapPicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    
    wrapPicker.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    state.wrap = chip.dataset.wrap === 'true';
  });

  // Theme Toggle
  themeToggle.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark');
    try {
      localStorage.setItem('snakeTheme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
    } catch (e) {}
  });

  // Load theme preference
  try {
    const savedTheme = localStorage.getItem('snakeTheme');
    if (savedTheme === 'dark') {
      document.documentElement.classList.add('dark');
    } else if (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.documentElement.classList.add('dark');
    }
  } catch (e) {}

  // Handle window resize
  window.addEventListener('resize', () => {
    setupCanvas();
  });

  // Initialize
  setupCanvas();
  requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
