<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake ‚Äî Smooth Google-like Clone (English)</title>
<style>
  :root{
    /* light theme */
    --bg: #f1f4f8;
    --panel: #4a752c;
    --accent: #34a853;
    --muted: #6b7280;
    --card: #e8eef1;
    --canvas-dark: #122116;
    --canvas-light: linear-gradient(#4c7f2f,#2d541e);
    --score-text: #ffffff;
  }
  /* dark theme variables */
  .dark {
    --bg: #0b0f12;
    --panel: #1f2923;
    --accent: #6fd48a;
    --muted: #9aa4a1;
    --card: #131617;
    --canvas-dark: linear-gradient(180deg,#0f2616,#07210f);
    --canvas-light: linear-gradient(120deg,#13311a,#0b2814);
    --score-text: #e8f7ea;
  }

  *{box-sizing:border-box;font-family:Inter, Roboto, Arial, sans-serif}
  html,body{height:100%;margin:0; background:var(--bg); display:flex; align-items:center; justify-content:center}
  .container{width:640px; max-width:95vw; display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px}
  .frame{width:620px;height:640px; max-width:100%; background:transparent; position:relative; border-radius:10px; overflow:visible}
  .topbar{height:70px;background:var(--panel); width:100%; border-radius:10px; display:flex; align-items:center; justify-content:space-between; padding:0 16px; color:var(--score-text)}
  .left{display:flex; align-items:center; gap:12px}
  .logoBox{width:42px;height:42px;border-radius:9px;display:flex;align-items:center;justify-content:center;font-weight:700;color:white;background:linear-gradient(135deg,#5bb24e,#2f6b24);box-shadow:0 6px 18px rgba(0,0,0,0.25)}
  .score{font-size:20px}
  .small{font-size:12px;color:rgba(255,255,255,0.85)}
  .right{display:flex;align-items:center;gap:10px}
  .iconBtn{width:36px;height:36;border-radius:8px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;cursor:pointer;border:none}
  .boardWrap{width:100%; background:var(--canvas-dark); height:calc(100% - 70px); display:flex; align-items:center; justify-content:center; position:relative; border-radius:0 0 10px 10px; overflow:hidden}
  canvas#main{background:var(--canvas-light); display:block; border-radius:6px; box-shadow: 0 8px 30px rgba(0,0,0,0.35)}
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
  .menuCard{width:340px;height:380px;background:linear-gradient(180deg,#4dc1f9,#2f9bd6); border-radius:12px; text-align:center; pointer-events:auto; display:flex; flex-direction:column;align-items:center; padding:26px; gap:12px; box-shadow:0 16px 40px rgba(0,0,0,0.35)}
  .menuCard h2{margin:0;color:#fff;font-size:30px}
  .controlsRow{display:flex; gap:10px; width:100%; padding:0 10px; margin-top:6px}
  .bigBtn{flex:1;background:#0ea5e9;border:none;color:#fff;padding:12px 8px;border-radius:10px;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center;gap:8px;box-shadow:0 6px 16px rgba(0,0,0,0.25)}
  .smallBtn{width:64px;background:#0ea5e9;border:none;color:#fff;padding:12px;border-radius:10px;cursor:pointer}
  .settingsPanel{position:absolute; right:14px; top:84px; width:320px; background:var(--card); border-radius:10px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.25); color:var(--muted); display:none; z-index:40}
  .optRow{display:flex; justify-content:space-between; align-items:center; padding:6px 4px}
  .picker{display:flex; gap:8px}
  .chip{padding:6px 10px;border-radius:10px;background:rgba(0,0,0,0.06); cursor:pointer; font-size:13px}
  .chip.active{background:var(--accent); color:white; box-shadow:0 6px 12px rgba(0,0,0,0.12)}
  .gameOver{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
  .goCard{background:rgba(0,0,0,0.7); color:#fff; padding:18px 22px; border-radius:12px; pointer-events:auto; text-align:center}
  .bottomBar{width:100%; margin-top:6px; display:flex; gap:8px; justify-content:space-between; align-items:center}
  .toggle{background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;border:none}
  .controls-on-screen{position:absolute;left:12px;bottom:18px;display:flex;flex-direction:column;gap:8px;pointer-events:auto}
  .arrowBtn{width:46px;height:46px;background:rgba(255,255,255,0.07);display:flex;align-items:center;justify-content:center;border-radius:8px}
  .sr-only{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;padding:0;margin:-1px}
  @media (max-width:700px){
    .frame{transform:scale(0.92)}
  }
</style>
</head>
<body>
  <div class="container" role="application" aria-label="Snake game">
    <div class="frame" id="frame">
      <div class="topbar" role="banner">
        <div class="left">
          <div class="logoBox">S</div>
          <div>
            <div class="score" id="scoreText">Score: <span id="score">0</span></div>
            <div class="small">Best: <span id="bestScore">0</span></div>
          </div>
        </div>
        <div class="right">
          <button class="iconBtn" id="themeToggle" title="Toggle theme" aria-pressed="false">
            <!-- sun/moon icon -->
            <svg id="themeIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg>
          </button>
          <button class="iconBtn" id="muteBtn" title="Mute / Unmute" aria-pressed="false">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff"><path d="M5 9v6h4l5 4V5L9 9H5z"/></svg>
          </button>
          <button class="iconBtn" id="settingsBtn" title="Settings">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z"/></svg>
          </button>
        </div>
      </div>

      <div class="boardWrap" role="main">
        <canvas id="main" width="600" height="530" aria-label="Game canvas"></canvas>

        <div class="overlay" id="overlay">
          <div class="menuCard" id="menuCard">
            <h2>Snake</h2>
            <div style="color:#e8f8ff">Classic arcade ‚Äî smooth experience</div>
            <div style="width:100%;margin-top:16px;display:flex;flex-direction:column;gap:10px;padding:0 8px">
              <div class="controlsRow">
                <button class="bigBtn" id="playBtn">‚ñ∂ Play</button>
              </div>
              <div class="controlsRow" style="justify-content:center">
                <button class="smallBtn" id="shuffleBtn" title="Randomize">üîÄ</button>
                <div style="flex:1"></div>
                <div style="color:white;font-weight:600">Keys: ‚Üê‚Üë‚Üí‚Üì or WASD</div>
              </div>
            </div>
            <div style="margin-top:auto;color:#fff;font-size:14px">Break your record ‚Äî enjoy the flow!</div>
          </div>
        </div>

        <div class="settingsPanel" id="settings">
          <div style="font-weight:700;margin-bottom:8px">Settings</div>
          <div class="optRow">
            <div>Speed</div>
            <div class="picker" id="speedPicker">
              <div class="chip" data-speed="0">Slow</div>
              <div class="chip active" data-speed="1">Normal</div>
              <div class="chip" data-speed="2">Fast</div>
            </div>
          </div>
          <div class="optRow">
            <div>Grid size</div>
            <div class="picker" id="sizePicker">
              <div class="chip" data-size="24">Small</div>
              <div class="chip active" data-size="20">Normal</div>
              <div class="chip" data-size="16">Large</div>
            </div>
          </div>
          <div class="optRow">
            <div>Theme</div>
            <div class="picker" id="themePicker">
              <div class="chip active" data-theme="green">Green</div>
              <div class="chip" data-theme="dark">Dark</div>
              <div class="chip" data-theme="light">Light</div>
            </div>
          </div>
          <div class="optRow" style="justify-content:center;">
            <button class="toggle" id="resetBtn">Reset Best</button>
          </div>
        </div>

        <div class="gameOver" id="gameOver" style="display:none">
          <div class="goCard">
            <div style="font-size:22px;font-weight:700">Game Over</div>
            <div style="margin:8px 0">Final score: <span id="finalScore">0</span></div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
              <button class="bigBtn" id="retryBtn" style="width:120px">Retry</button>
              <button class="bigBtn" id="menuBtn" style="width:120px">Menu</button>
            </div>
          </div>
        </div>

        <!-- simple on-screen arrows for mobile -->
        <div class="controls-on-screen" aria-hidden="true">
          <div style="display:flex;gap:8px">
            <div class="arrowBtn" id="upBtn">‚ñ≤</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="arrowBtn" id="leftBtn">‚óÄ</div>
            <div style="width:8px"></div>
            <div class="arrowBtn" id="rightBtn">‚ñ∂</div>
          </div>
          <div style="display:flex;gap:8px">
            <div class="arrowBtn" id="downBtn">‚ñº</div>
          </div>
        </div>

      </div>

    </div>

    <div class="bottomBar" style="width:620px; max-width:100%">
      <div style="display:flex;gap:8px">
        <button class="toggle" id="pauseBtn">Pause</button>
        <button class="toggle" id="wrapBtn" data-wrap="true">Wrap: ON</button>
      </div>
      <div style="color:var(--muted)">Mobile: Swipe or use on-screen arrows</div>
    </div>
  </div>

<script>
/* Smooth Snake (English) - improvements:
   - devicePixelRatio canvas scaling for crisp rendering
   - smooth interpolation between grid cells for visual fluidity
   - dark mode support with system preference + manual toggle
   - touch swipe controls and on-screen arrows
   - settings: speed, size, theme; best score persisted
*/

(() => {
  // ---------------- DOM
  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d', { alpha: false });
  const overlay = document.getElementById('overlay');
  const playBtn = document.getElementById('playBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settings');
  const speedPicker = document.getElementById('speedPicker');
  const sizePicker = document.getElementById('sizePicker');
  const themePicker = document.getElementById('themePicker');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('bestScore');
  const gameOverEl = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const retryBtn = document.getElementById('retryBtn');
  const menuBtn = document.getElementById('menuBtn');
  const muteBtn = document.getElementById('muteBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const wrapBtn = document.getElementById('wrapBtn');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const themeToggle = document.getElementById('themeToggle');
  const themeIcon = document.getElementById('themeIcon');

  // on-screen arrows
  const upBtn = document.getElementById('upBtn');
  const downBtn = document.getElementById('downBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');

  // ---------------- config + state
  let cols = 20;
  let rows = 17;
  let cellSize = 30; // pixel logical size (will be scaled by DPR)
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let speedLevel = 1;
  const speedMap = [5, 8, 12]; // moves per second
  let movesPerSecond = speedMap[speedLevel];
  let moveInterval = 1000 / movesPerSecond;
  let wrap = true;
  let muted = false;
  let running = false;

  // interpolation and timing
  let lastTick = performance.now();
  let accumulated = 0; // ms since last move used for interpolation

  // snake state (grid coordinates)
  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = null;
  let apple = null;
  let score = 0;
  let best = Number(localStorage.getItem('snake_best') || 0);
  bestEl.textContent = best;

  // initialize canvas size & scale
  function setupCanvas(){
    // logical CSS size
    const cssWidth = 600;
    const cssHeight = 530;
    canvas.style.width = cssWidth + 'px';
    canvas.style.height = cssHeight + 'px';
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing operations by DPR
    // recalc cell size based on cols
    cellSize = Math.floor(cssWidth / cols);
    rows = Math.floor(cssHeight / cellSize);
  }
  dpr = Math.max(1, window.devicePixelRatio || 1);
  setupCanvas();

  // ---------------- sounds (simple beep)
  let audioCtx = null;
  function beep(freq=440, dur=0.05, vol=0.04){
    if(muted) return;
    try {
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch(e){}
  }

  // ---------------- game functions
  function resizeGrid(newCols){
    cols = newCols;
    setupCanvas();
  }

  function placeApple(){
    const taken = new Set(snake.map(p => p.x+','+p.y));
    for(let attempts=0; attempts<1000; attempts++){
      const a = { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) };
      if(!taken.has(a.x+','+a.y)) { apple = a; return; }
    }
    apple = null;
  }

  function startGame(){
    // reset
    // ensure cols, rows set
    cellSize = Math.floor(parseInt(canvas.style.width) / cols);
    rows = Math.floor(parseInt(canvas.style.height) / cellSize);
    const cx = Math.floor(cols/2);
    const cy = Math.floor(rows/2);
    snake = [{x:cx-1,y:cy},{x:cx,y:cy}];
    dir = {x:1,y:0};
    nextDir = null;
    score = 0;
    updateScore();
    placeApple();
    running = true;
    accumulated = 0;
    lastTick = performance.now();
    overlay.style.display = 'none';
    gameOverEl.style.display = 'none';
    pauseBtn.textContent = 'Pause';
    // resume audio context on user gesture
    try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
  }

  function updateScore(){
    scoreEl.textContent = score;
    if(score > best){
      best = score;
      localStorage.setItem('snake_best', String(best));
      bestEl.textContent = best;
    }
  }

  function die(){
    running = false;
    beep(140, 0.12, 0.08);
    finalScoreEl.textContent = score;
    gameOverEl.style.display = 'flex';
    overlay.style.display = 'none';
    updateScore();
  }

  // Game tick (discrete move)
  function gameTick(){
    // apply nextDir if valid
    if(nextDir){
      if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
      nextDir = null;
    }
    const head = snake[snake.length-1];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    if(wrap){
      if(nx < 0) nx = cols - 1;
      if(nx >= cols) nx = 0;
      if(ny < 0) ny = rows - 1;
      if(ny >= rows) ny = 0;
    } else {
      if(nx < 0 || nx >= cols || ny < 0 || ny >= rows) {
        return die();
      }
    }

    // collision with self
    for(let i=0;i<snake.length;i++){
      if(snake[i].x === nx && snake[i].y === ny) return die();
    }

    // move
    snake.push({x:nx,y:ny});
    // eat?
    if(apple && nx===apple.x && ny===apple.y){
      score++;
      updateScore();
      beep(760,0.04,0.06);
      placeApple();
    } else {
      snake.shift();
    }
  }

  // ---------------- rendering (smooth interpolation)
  function draw(now, interpolation){
    // clear background
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);

    // draw board grid area centered vertically
    const boardW = cols * cellSize;
    const boardH = rows * cellSize;
    const offsetX = Math.floor((parseInt(canvas.style.width) - boardW)/2);
    const offsetY = Math.floor((parseInt(canvas.style.height) - boardH)/2);

    // background tiles
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = offsetX + c*cellSize;
        const y = offsetY + r*cellSize;
        ctx.fillStyle = ((c + r) % 2 === 0) ? '#4b7730' : '#437022';
        // adapt for theme dark: subtle darker variants
        if(document.documentElement.classList.contains('dark')){
          ctx.fillStyle = ((c + r) % 2 === 0) ? '#0f3216' : '#09240f';
        }
        ctx.fillRect(x, y, cellSize, cellSize);
      }
    }

    // draw apple with a little pop animation
    if(apple){
      // apple center
      const apx = offsetX + apple.x * cellSize + cellSize/2;
      const apy = offsetY + apple.y * cellSize + cellSize/2;
      const base = cellSize * 0.6;
      // subtle bob using time
      const t = (Date.now()%800)/800;
      const bob = Math.sin(t * Math.PI * 2) * (cellSize*0.03);
      const size = base + bob;
      ctx.save();
      ctx.translate(apx, apy);
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(0, size*0.35, size*0.45, size*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      // apple body
      const grad = ctx.createLinearGradient(-size/2, -size/2, size/2, size/2);
      grad.addColorStop(0, '#ff6b6b');
      grad.addColorStop(1, '#ff2e2e');
      ctx.fillStyle = grad;
      roundRect(ctx, -size/2, -size/2, size, size, size*0.2, true);
      // stem
      ctx.fillStyle = '#6b4a2a';
      ctx.fillRect(-size*0.05, -size*0.6, size*0.1, size*0.25);
      ctx.restore();
    }

    // draw snake with interpolation between last and current positions
    // We need previous positions for smoothing: compute positions array that interpolates between previous and next state
    // We store visual positions in "vpos" array
    const vpos = [];
    for(let i=0;i<snake.length;i++){
      vpos.push({x: snake[i].x, y: snake[i].y});
    }
    // When interpolation value is fraction between ticks, shift head back towards previous head:
    // We handle by drawing segments where head is interpolated from previous head to current head using dir and interpolation
    // For smoother look, render body segments with slight scaling for head.
    const interp = interpolation; // 0..1
    // compute previous head for interpolation: not available explicitly, approximate by subtracting dir
    if(snake.length >= 2){
      // last element is head
      const head = snake[snake.length-1];
      const prevHead = snake[snake.length-2];
      // interpolate head
      const hx = prevHead.x + (head.x - prevHead.x)*interp;
      const hy = prevHead.y + (head.y - prevHead.y)*interp;
      // draw body segments
      for(let i=0;i<snake.length;i++){
        const p = snake[i];
        // segment position for drawing: if it's head use hx/hy, else draw normally but offset a tiny bit by interpolation for smoother motion
        let drawX = p.x, drawY = p.y;
        if(i === snake.length-1){
          drawX = hx; drawY = hy;
        } else if(i === snake.length-2){
          // the segment before head slightly follows
          drawX = p.x + ( (snake[snake.length-1].x - p.x) * interp * 0.6 );
          drawY = p.y + ( (snake[snake.length-1].y - p.y) * interp * 0.6 );
        }
        const px = offsetX + drawX*cellSize;
        const py = offsetY + drawY*cellSize;
        // size easing for tail vs head
        const t = i / Math.max(1, snake.length-1);
        const segSize = cellSize * (i === snake.length-1 ? 0.95 : 0.88);
        // color gradient
        let rcol = 28, gcol = Math.floor(120 + (80 * (1 - t))), bcol = 36;
        if(document.documentElement.classList.contains('dark')){
          rcol = 180; gcol = Math.floor(240 - 40*t); bcol = 210;
        }
        ctx.fillStyle = `rgb(${rcol},${gcol},${bcol})`;
        // draw rounded rect slightly inset
        roundRect(ctx, px + (cellSize - segSize)/2, py + (cellSize - segSize)/2, segSize, segSize, segSize*0.18, true);
        // head highlight
        if(i === snake.length-1){
          ctx.fillStyle = document.documentElement.classList.contains('dark') ? 'rgba(255,255,255,0.92)' : 'rgba(255,255,255,0.9)';
          const eyeW = cellSize*0.06;
          const ex = px + segSize*0.35;
          const ey = py + segSize*0.33;
          ctx.fillRect(ex, ey, Math.max(1,eyeW), Math.max(1,eyeW));
          ctx.fillRect(ex + segSize*0.18, ey, Math.max(1,eyeW), Math.max(1,eyeW));
        }
      }
    } else {
      // fallback draw straight
      for(let i=0;i<snake.length;i++){
        const p = snake[i];
        const px = offsetX + p.x*cellSize;
        const py = offsetY + p.y*cellSize;
        const segSize = cellSize*0.9;
        ctx.fillStyle = '#2f6b24';
        roundRect(ctx, px + (cellSize-segSize)/2, py + (cellSize-segSize)/2, segSize, segSize, segSize*0.18, true);
      }
    }

    // subtle grid border
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX, offsetY, boardW, boardH);
  }

  // helper: rounded rectangle
  function roundRect(ctx,x,y,w,h,r,fill){
    const radius = Math.max(0, r);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  // ---------------- main loop (game logic and interpolation)
  let raf = null;
  function mainLoop(now){
    if(!lastTick) lastTick = now;
    const dt = now - lastTick;
    lastTick = now;
    accumulated += dt;

    // discrete ticks (game moves)
    const interval = moveInterval;
    while(running && accumulated >= interval){
      gameTick();
      accumulated -= interval;
    }

    // interpolation fraction between ticks
    const frac = Math.min(1, accumulated / interval);
    draw(now, frac);

    raf = requestAnimationFrame(mainLoop);
  }

  raf = requestAnimationFrame(mainLoop);

  // ---------------- input
  function setDirection(dx,dy){
    const nd = {x:dx,y:dy};
    // prevent instant reverse
    const head = snake[snake.length-1];
    const neck = snake.length>1 ? snake[snake.length-2] : null;
    if(neck && neck.x === head.x + nd.x && neck.y === head.y + nd.y) return;
    nextDir = nd;
  }

  window.addEventListener('keydown', (e) => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].indexOf(e.key) === -1) return;
    e.preventDefault();
    if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') setDirection(0,-1);
    if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') setDirection(0,1);
    if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') setDirection(-1,0);
    if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') setDirection(1,0);
  });

  // on-screen buttons
  upBtn.addEventListener('click', ()=> setDirection(0,-1));
  downBtn.addEventListener('click', ()=> setDirection(0,1));
  leftBtn.addEventListener('click', ()=> setDirection(-1,0));
  rightBtn.addEventListener('click', ()=> setDirection(1,0));

  // Touch swipe detection
  let touchStart = null;
  window.addEventListener('touchstart', (e) => {
    if(e.touches && e.touches.length === 1){
      const t = e.touches[0];
      touchStart = {x:t.clientX, y:t.clientY, time: Date.now()};
    }
  }, {passive:true});
  window.addEventListener('touchend', (e) => {
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const threshold = 24; // px
    if(Math.max(adx,ady) > threshold){
      if(adx > ady){
        if(dx > 0) setDirection(1,0); else setDirection(-1,0);
      } else {
        if(dy > 0) setDirection(0,1); else setDirection(0,-1);
      }
    }
    touchStart = null;
  }, {passive:true});

  // ---------------- UI events
  playBtn.addEventListener('click', () => {
    startGame();
  });
  retryBtn.addEventListener('click', () => startGame());
  menuBtn.addEventListener('click', () => {
    overlay.style.display = 'flex';
    settingsPanel.style.display = 'none';
    gameOverEl.style.display = 'none';
    running = false;
  });

  pauseBtn.addEventListener('click', () => {
    running = !running;
    pauseBtn.textContent = running ? 'Pause' : 'Resume';
  });

  settingsBtn.addEventListener('click', () => {
    settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
  });

  muteBtn.addEventListener('click', () => {
    muted = !muted;
    muteBtn.style.opacity = muted ? 0.5 : 1;
    muteBtn.setAttribute('aria-pressed', String(muted));
  });

  wrapBtn.addEventListener('click', () => {
    wrap = !wrap;
    wrapBtn.dataset.wrap = String(wrap);
    wrapBtn.textContent = `Wrap: ${wrap ? 'ON' : 'OFF'}`;
  });

  shuffleBtn.addEventListener('click', () => {
    const sizes = [24,20,16];
    const speeds = [0,1,2];
    const themes = ['green','dark','light'];
    const s = sizes[Math.floor(Math.random()*sizes.length)];
    const sp = speeds[Math.floor(Math.random()*speeds.length)];
    const th = themes[Math.floor(Math.random()*themes.length)];
    applySize(s);
    applySpeed(sp);
    applyTheme(th);
  });

  // pickers (event delegation)
  speedPicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if(!chip) return;
    const idx = Number(chip.dataset.speed);
    applySpeed(idx);
  });
  sizePicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if(!chip) return;
    const size = Number(chip.dataset.size);
    applySize(size);
  });
  themePicker.addEventListener('click', (e) => {
    const chip = e.target.closest('.chip');
    if(!chip) return;
    applyTheme(chip.dataset.theme);
  });
  resetBtn.addEventListener('click', () => {
    localStorage.removeItem('snake_best');
    best = 0;
    bestEl.textContent = best;
  });

  // apply helpers
  function applySpeed(idx){
    [...speedPicker.querySelectorAll('.chip')].forEach(c=>c.classList.remove('active'));
    const active = speedPicker.querySelector(`.chip[data-speed="${idx}"]`);
    if(active) active.classList.add('active');
    speedLevel = idx;
    movesPerSecond = speedMap[speedLevel];
    moveInterval = 1000 / movesPerSecond;
  }
  function applySize(sizeCols){
    [...sizePicker.querySelectorAll('.chip')].forEach(c=>c.classList.remove('active'));
    const active = sizePicker.querySelector(`.chip[data-size="${sizeCols}"]`);
    if(active) active.classList.add('active');
    resizeGrid(sizeCols);
    // restart visual layout but don't force new game; if running, re-init to keep stable
    if(running) startGame();
  }
  function applyTheme(th){
    [...themePicker.querySelectorAll('.chip')].forEach(c=>c.classList.remove('active'));
    const active = themePicker.querySelector(`.chip[data-theme="${th}"]`);
    if(active) active.classList.add('active');

    if(th === 'dark'){
      document.documentElement.classList.add('dark');
      themeToggle.setAttribute('aria-pressed','true');
    } else if(th === 'light'){
      document.documentElement.classList.remove('dark');
      themeToggle.setAttribute('aria-pressed','false');
      // light uses default variables
    } else {
      // green: prefer light but green accent
      document.documentElement.classList.remove('dark');
      themeToggle.setAttribute('aria-pressed','false');
    }
  }

  // initialize pickers
  (function initPickers(){
    const activeSpeed = speedPicker.querySelector('.chip.active');
    if(activeSpeed) applySpeed(Number(activeSpeed.dataset.speed));
    const activeSize = sizePicker.querySelector('.chip.active');
    if(activeSize) applySize(Number(activeSize.dataset.size));
    const activeTheme = themePicker.querySelector('.chip.active');
    if(activeTheme) applyTheme(activeTheme.dataset.theme);
  })();

  // theme toggle (system preference + manual)
  function applySystemTheme(){
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if(prefersDark){
      document.documentElement.classList.add('dark');
      themeToggle.setAttribute('aria-pressed','true');
    } else {
      document.documentElement.classList.remove('dark');
      themeToggle.setAttribute('aria-pressed','false');
    }
  }
  // initial
  applySystemTheme();
  window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applySystemTheme);

  themeToggle.addEventListener('click', () => {
    if(document.documentElement.classList.contains('dark')){
      document.documentElement.classList.remove('dark');
      themeToggle.setAttribute('aria-pressed','false');
    } else {
      document.documentElement.classList.add('dark');
      themeToggle.setAttribute('aria-pressed','true');
    }
  });

  // update dpr/resizing
  window.addEventListener('resize', ()=>{
    dpr = Math.max(1, window.devicePixelRatio || 1);
    setupCanvas();
  });

  // helper: randomize initial apple if none
  if(!apple) placeApple();

  // expose for debugging
  window._snake = { startGame, applySize, applySpeed, applyTheme };

  // small accessibility: focusable play button
  playBtn.focus();

})();
</script>
</body>
</html>
