<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake ‚Äî Enhanced Playground (Fixed)</title>
<style>
  :root{
    --bg: #f1f4f8;
    --panel: #4a752c;
    --accent: #34a853;
    --muted: #6b7280;
    --card: #e8eef1;
    --canvas-dark: #122116;
    --canvas-light: linear-gradient(#4c7f2f,#2d541e);
    --score-text: #ffffff;
  }
  .dark {
    --bg: #0b0f12;
    --panel: #1f2923;
    --accent: #6fd48a;
    --muted: #9aa4a1;
    --card: #131617;
    --canvas-dark: linear-gradient(180deg,#0f2616,#07210f);
    --canvas-light: linear-gradient(120deg,#13311a,#0b2814);
    --score-text: #e8f7ea;
  }

  *{box-sizing:border-box;font-family:Inter, Roboto, Arial, sans-serif}
  html,body{height:100%;margin:0; background:var(--bg); display:flex; align-items:center; justify-content:center}
  .container{width:640px; max-width:95vw; display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px}
  .frame{width:620px;height:640px; max-width:100%; background:transparent; position:relative; border-radius:10px; overflow:visible}
  .topbar{height:70px;background:var(--panel); width:100%; border-radius:10px; display:flex; align-items:center; justify-content:space-between; padding:0 16px; color:var(--score-text)}
  .left{display:flex; align-items:center; gap:12px}
  .logoBox{width:42px;height:42px;border-radius:9px;display:flex;align-items:center;justify-content:center;font-weight:700;color:white;background:linear-gradient(135deg,#5bb24e,#2f6b24);box-shadow:0 6px 18px rgba(0,0,0,0.25)}
  .score{font-size:20px}
  .right{display:flex;align-items:center;gap:10px}
  .iconBtn{width:36px;height:36;border-radius:8px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;cursor:pointer;border:none}
  .boardWrap{width:100%; background:var(--canvas-dark); height:calc(100% - 70px); display:flex; align-items:center; justify-content:center; position:relative; border-radius:0 0 10px 10px; overflow:hidden}
  canvas#main{background:var(--canvas-light); display:block; border-radius:6px; box-shadow: 0 8px 30px rgba(0,0,0,0.35)}
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
  .menuCard{width:340px;height:420px;background:linear-gradient(180deg,#4dc1f9,#2f9bd6); border-radius:12px; text-align:center; pointer-events:auto; display:flex; flex-direction:column;align-items:center; padding:22px; gap:12px; box-shadow:0 16px 40px rgba(0,0,0,0.35); transform-origin:center; transition:transform .28s cubic-bezier(.2,.9,.2,1)}
  .menuCard.enter{transform:scale(1)}
  .menuCard.exit{transform:scale(.88);opacity:0}
  .menuCard h2{margin:0;color:#fff;font-size:30px}
  .controlsRow{display:flex; gap:10px; width:100%; padding:0 10px; margin-top:6px}
  .bigBtn{flex:1;background:#0ea5e9;border:none;color:#fff;padding:12px 8px;border-radius:10px;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center;gap:8px;box-shadow:0 6px 16px rgba(0,0,0,0.25)}
  .smallBtn{width:64px;background:#0ea5e9;border:none;color:#fff;padding:12px;border-radius:10px;cursor:pointer}
  .settingsPanel{position:absolute; right:14px; top:84px; width:320px; background:var(--card); border-radius:10px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.25); color:var(--muted); display:none; z-index:40}
  .optRow{display:flex; justify-content:space-between; align-items:center; padding:6px 4px}
  .picker{display:flex; gap:8px}
  .chip{padding:6px 10px;border-radius:10px;background:rgba(0,0,0,0.06); cursor:pointer; font-size:13px}
  .chip.active{background:var(--accent); color:white; box-shadow:0 6px 12px rgba(0,0,0,0.12)}
  .gameOver{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
  .goCard{background:rgba(0,0,0,0.7); color:#fff; padding:18px 22px; border-radius:12px; pointer-events:auto; text-align:center}
  .bottomBar{width:100%; margin-top:6px; display:flex; gap:8px; justify-content:space-between; align-items:center}
  .toggle{background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;border:none}
  .sr-only{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;padding:0;margin:-1px}
  .popup-plus{position:absolute;left:50%;transform:translateX(-50%);top:22px;color:#fff;font-weight:700;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.45);pointer-events:none;opacity:0;transition:transform .45s,opacity .45s}
  @media (max-width:700px){
    .frame{transform:scale(0.92)}
    .menuCard{width:86vw;height:46vh}
  }
</style>
</head>
<body>
  <div class="container" role="application" aria-label="Snake game">
    <div class="frame" id="frame">
      <div class="topbar" role="banner">
        <div class="left">
          <div class="logoBox">S</div>
          <div>
            <div class="score" id="scoreText">Score: <span id="score">0</span></div>
          </div>
        </div>
        <div class="right">
          <button class="iconBtn" id="themeToggle" title="Toggle theme" aria-pressed="false">
            <svg id="themeIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg>
          </button>
          <button class="iconBtn" id="settingsBtn" title="Settings">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z"/></svg>
          </button>
        </div>
      </div>

      <div class="boardWrap" role="main">
        <canvas id="main" width="600" height="530" aria-label="Game canvas"></canvas>

        <div class="overlay" id="overlay">
          <div class="menuCard enter" id="menuCard">
            <h2>Snake</h2>
            <div style="color:#e8f8ff">Classic arcade ‚Äî smoother & more fun</div>
            <div style="width:100%;margin-top:12px;display:flex;flex-direction:column;gap:10px;padding:0 8px">
              <div class="controlsRow">
                <button class="bigBtn" id="playBtn">‚ñ∂ Play</button>
              </div>
              <div class="controlsRow" style="justify-content:center">
                <button class="smallBtn" id="shuffleBtn" title="Randomize">üîÄ</button>
                <div style="flex:1"></div>
                <div style="color:white;font-weight:600">Keys: ‚Üê‚Üë‚Üí‚Üì or WASD ‚Äî Swipe on mobile</div>
              </div>
            </div>
            <div style="margin-top:auto;color:#fff;font-size:13px">Look for the rare golden apple ‚Äî it feels great to catch it ‚ú®</div>
          </div>
        </div>

        <div id="eatPopup" class="popup-plus" aria-hidden="true">+0</div>

        <div class="settingsPanel" id="settings">
          <div style="font-weight:700;margin-bottom:8px">Settings</div>
          <div class="optRow">
            <div>Speed</div>
            <div class="picker" id="speedPicker">
              <div class="chip" data-speed="0">Slow</div>
              <div class="chip active" data-speed="1">Normal</div>
              <div class="chip" data-speed="2">Fast</div>
            </div>
          </div>
          <div class="optRow">
            <div>Grid size</div>
            <div class="picker" id="sizePicker">
              <div class="chip" data-size="24">Small</div>
              <div class="chip active" data-size="20">Normal</div>
              <div class="chip" data-size="16">Large</div>
            </div>
          </div>
          <div class="optRow">
            <div>Theme</div>
            <div class="picker" id="themePicker">
              <div class="chip active" data-theme="light">Light</div>
              <div class="chip" data-theme="dark">Dark</div>
            </div>
          </div>
          <div style="font-size:12px;color:var(--muted);margin-top:8px">Tip: Golden apple appears rarely and gives bigger score.</div>
        </div>

        <div class="gameOver" id="gameOver" style="display:none">
          <div class="goCard">
            <div style="font-size:22px;font-weight:700">Game Over</div>
            <div style="margin:8px 0">Final score: <span id="finalScore">0</span></div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
              <button class="bigBtn" id="retryBtn" style="width:120px">Retry</button>
              <button class="bigBtn" id="menuBtn" style="width:120px">Menu</button>
            </div>
          </div>
        </div>

      </div>

    </div>

    <div class="bottomBar" style="width:620px; max-width:100%">
      <div style="display:flex;gap:8px">
        <button class="toggle" id="pauseBtn">Pause</button>
        <button class="toggle" id="wrapBtn" data-wrap="true">Wrap: ON</button>
      </div>
      <div style="color:var(--muted)">Mobile: Swipe on the canvas to move ‚Äî hunt the golden apple!</div>
    </div>
  </div>

<script>
// SNAKE GAME - Improved, single-file version
// All logic, styles, and markup are in this file for easy portability and maintenance.

(function () {
  // --- DOM Elements ---
  const $ = id => document.getElementById(id);
  const canvas = $("main");
  const ctx = canvas.getContext("2d", { alpha: false });
  const overlay = $("overlay");
  const menuCard = $("menuCard");
  const playBtn = $("playBtn");
  const settingsBtn = $("settingsBtn");
  const settingsPanel = $("settings");
  const speedPicker = $("speedPicker");
  const sizePicker = $("sizePicker");
  const themePicker = $("themePicker");
  const scoreEl = $("score");
  const gameOverEl = $("gameOver");
  const finalScoreEl = $("finalScore");
  const retryBtn = $("retryBtn");
  const menuBtn = $("menuBtn");
  const pauseBtn = $("pauseBtn");
  const wrapBtn = $("wrapBtn");
  const shuffleBtn = $("shuffleBtn");
  const themeToggle = $("themeToggle");
  const eatPopup = $("eatPopup");

  // --- Game Config & State ---
  let cols = 20, rows = 17, cellSize = 30;
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let speedLevel = 1;
  const speedMap = [5, 8, 12]; // moves/sec
  let movesPerSecond = speedMap[speedLevel];
  let moveInterval = 1000 / movesPerSecond;
  let wrap = true, running = false;
  let lastTick = performance.now(), accumulated = 0;
  let snake = [], dir = { x: 1, y: 0 }, nextDir = null, apple = null, score = 0;
  let particles = [], trail = [], shake = { x: 0, y: 0, decay: 0.9 };
  const PARTICLE_CAP = 260, TRAIL_MAX = 18;
  let audioCtx = null;

  // --- Utility Functions ---
  function setupCanvas() {
    const cssWidth = 600, cssHeight = 530;
    canvas.style.width = cssWidth + "px";
    canvas.style.height = cssHeight + "px";
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cellSize = Math.floor(cssWidth / cols);
    rows = Math.floor(cssHeight / cellSize);
  }

  function beep(freq = 440, dur = 0.05, vol = 0.04) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch (e) { }
  }

  function placeApple() {
    const taken = new Set(snake.map(p => p.x + "," + p.y));
    for (let attempts = 0; attempts < 3000; attempts++) {
      const a = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
      if (!taken.has(a.x + "," + a.y)) {
        a.type = Math.random() < 0.10 ? "gold" : "normal";
        apple = a;
        return;
      }
    }
    // fallback: scan for first free
    for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) if (!taken.has(x + "," + y)) { apple = { x, y, type: "normal" }; return; }
    apple = null;
  }

  function spawnParticles(x, y, color, count = 18) {
    const allowed = Math.max(0, PARTICLE_CAP - particles.length);
    const toSpawn = Math.min(count, allowed);
    for (let i = 0; i < toSpawn; i++) {
      const ang = Math.random() * Math.PI * 2, speed = Math.random() * 1.6 + 0.6;
      particles.push({
        x, y,
        vx: Math.cos(ang) * speed,
        vy: Math.sin(ang) * speed - 0.5,
        life: 600 + Math.random() * 400,
        born: performance.now(),
        size: 2 + Math.random() * 3,
        color
      });
    }
  }

  function updateParticles(dt) {
    const now = performance.now();
    particles = particles.filter(p => (now - p.born) < p.life);
    for (let p of particles) {
      p.vy += 0.06 * (dt / 16);
      p.x += p.vx * (dt / 16);
      p.y += p.vy * (dt / 16);
    }
  }

  function pushTrail(px, py) {
    trail.push({ x: px, y: py, t: performance.now() });
    if (trail.length > TRAIL_MAX) trail.shift();
  }

  function gridToPixel(gx, gy) {
    const boardW = cols * cellSize, boardH = rows * cellSize;
    const offsetX = Math.floor((parseInt(canvas.style.width) - boardW) / 2);
    const offsetY = Math.floor((parseInt(canvas.style.height) - boardH) / 2);
    return { x: offsetX + gx * cellSize + cellSize / 2, y: offsetY + gy * cellSize + cellSize / 2 };
  }

  function roundRect(ctx, x, y, w, h, r, fill) {
    const radius = Math.max(0, r);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
    if (fill) ctx.fill(); else ctx.stroke();
  }

  // --- Game Logic ---
  function startGame() {
    cols = cols || 20;
    const cx = Math.floor(cols / 2), cy = Math.floor(rows / 2);
    snake = [{ x: cx - 1, y: cy }, { x: cx, y: cy }];
    dir = { x: 1, y: 0 };
    nextDir = null;
    score = 0;
    updateScore();
    placeApple();
    trail = [];
    particles = [];
    shake.x = 0; shake.y = 0;
    running = true;
    accumulated = 0;
    lastTick = performance.now();
    overlay.style.display = "none";
    gameOverEl.style.display = "none";
    menuCard.classList.remove("exit");
    pauseBtn.textContent = "Pause";
    if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
  }

  function updateScore() {
    scoreEl.textContent = score;
  }

  function showEatPopup(text) {
    if (!eatPopup) return;
    eatPopup.textContent = text;
    eatPopup.style.opacity = "1";
    eatPopup.style.transform = "translateX(-50%) translateY(-6px) scale(1.02)";
    eatPopup.style.transition = "none";
    requestAnimationFrame(() => {
      eatPopup.style.transition = "transform .6s cubic-bezier(.2,.8,.2,1),opacity .6s";
      eatPopup.style.transform = "translateX(-50%) translateY(-36px) scale(0.98)";
      eatPopup.style.opacity = "0";
    });
  }

  function die() {
    running = false;
    shake.x += (Math.random() * 8 - 4);
    shake.y += (Math.random() * 8 - 4);
    beep(120, 0.16, 0.08);
    finalScoreEl.textContent = score;
    gameOverEl.style.display = "flex";
    overlay.style.display = "none";
    updateScore();
  }

  function gameTick() {
    if (nextDir && !(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
    nextDir = null;
    const head = snake[snake.length - 1];
    let nx = head.x + dir.x, ny = head.y + dir.y;
    if (wrap) {
      if (nx < 0) nx = cols - 1;
      if (nx >= cols) nx = 0;
      if (ny < 0) ny = rows - 1;
      if (ny >= rows) ny = 0;
    } else {
      if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return die();
    }
    for (let i = 0; i < snake.length; i++) if (snake[i].x === nx && snake[i].y === ny) return die();
    snake.push({ x: nx, y: ny });
    if (apple && nx === apple.x && ny === apple.y) {
      const gained = apple.type === "gold" ? 3 : 1;
      score += gained;
      updateScore();
      try {
        if (apple.type === "gold") {
          beep(1100, 0.08, 0.08);
          if (navigator && navigator.vibrate) navigator.vibrate([30, 20, 30]);
          const pos = gridToPixel(apple.x, apple.y);
          spawnParticles(pos.x, pos.y, "gold", 32);
          shake.x += (Math.random() * 6 - 3);
          shake.y += (Math.random() * 6 - 3);
          showEatPopup("+" + gained + " ‚ú®");
        } else {
          beep(760, 0.04, 0.06);
          if (navigator && navigator.vibrate) navigator.vibrate(30);
          const pos = gridToPixel(apple.x, apple.y);
          spawnParticles(pos.x, pos.y, "red", 18);
          shake.x += (Math.random() * 2 - 1);
          shake.y += (Math.random() * 2 - 1);
          showEatPopup("+" + gained);
        }
      } catch (e) { }
      placeApple();
    } else {
      snake.shift();
    }
    // Dynamic speed increase
    const extra = Math.floor(score / 6) * 0.6;
    movesPerSecond = speedMap[speedLevel] + extra;
    movesPerSecond = Math.min(40, Math.max(3, movesPerSecond));
    moveInterval = 1000 / movesPerSecond;
  }

  // --- Drawing ---
  function draw(now, interpolation) {
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    const boardW = cols * cellSize, boardH = rows * cellSize;
    const offsetX = Math.floor((parseInt(canvas.style.width) - boardW) / 2);
    const offsetY = Math.floor((parseInt(canvas.style.height) - boardH) / 2);
    const sx = shake.x * 0.6, sy = shake.y * 0.6;
    // Draw board
    for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
      const x = offsetX + c * cellSize + sx, y = offsetY + r * cellSize + sy;
      let fill = (c + r) % 2 === 0 ? "#4b7730" : "#437022";
      if (document.documentElement.classList.contains("dark")) fill = (c + r) % 2 === 0 ? "#0f3216" : "#09240f";
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, cellSize, cellSize);
    }
    // Ghost trail
    ctx.save();
    for (let i = 0; i < trail.length; i++) {
      const t = trail[i];
      const alpha = Math.max(0, 0.55 - (i / trail.length) * 0.5);
      ctx.globalAlpha = alpha * 0.8;
      ctx.fillStyle = document.documentElement.classList.contains("dark") ? "#9be2a0" : "#cfeec7";
      const px = offsetX + t.x * cellSize + sx, py = offsetY + t.y * cellSize + sy;
      const radius = cellSize * (0.34 - i * 0.012);
      ctx.beginPath();
      ctx.ellipse(px + cellSize / 2, py + cellSize / 2, radius, radius, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
    // Apple
    if (apple) {
      const apx = offsetX + apple.x * cellSize + cellSize / 2 + sx, apy = offsetY + apple.y * cellSize + cellSize / 2 + sy;
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.beginPath(); ctx.ellipse(apx, apy + cellSize * 0.28, cellSize * 0.38, cellSize * 0.14, 0, 0, Math.PI * 2); ctx.fill();
      if (apple.type === "gold") {
        const g = ctx.createLinearGradient(apx - 12, apy - 12, apx + 12, apy + 12);
        g.addColorStop(0, "#ffe28a"); g.addColorStop(1, "#ffb74d");
        ctx.fillStyle = g;
        roundRect(ctx, apx - cellSize * 0.36, apy - cellSize * 0.36, cellSize * 0.72, cellSize * 0.72, cellSize * 0.18, true);
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillRect(apx - 6, apy - cellSize * 0.12, 3, 3);
      } else {
        const grad = ctx.createLinearGradient(apx - 12, apy - 12, apx + 12, apy + 12);
        grad.addColorStop(0, "#ff8a8a"); grad.addColorStop(1, "#ff3b3b");
        ctx.fillStyle = grad;
        roundRect(ctx, apx - cellSize * 0.32, apy - cellSize * 0.32, cellSize * 0.64, cellSize * 0.64, cellSize * 0.16, true);
      }
      ctx.restore();
    }
    // Snake
    if (snake.length >= 2) {
      const head = snake[snake.length - 1], prevHead = snake[snake.length - 2];
      const hx = prevHead.x + (head.x - prevHead.x) * interpolation;
      const hy = prevHead.y + (head.y - prevHead.y) * interpolation;
      for (let i = 0; i < snake.length; i++) {
        const p = snake[i];
        let drawX = p.x, drawY = p.y;
        if (i === snake.length - 1) { drawX = hx; drawY = hy; }
        else if (i === snake.length - 2) {
          drawX = p.x + ((snake[snake.length - 1].x - p.x) * interpolation * 0.6);
          drawY = p.y + ((snake[snake.length - 1].y - p.y) * interpolation * 0.6);
        }
        const px = offsetX + drawX * cellSize + sx, py = offsetY + drawY * cellSize + sy;
        const t = i / Math.max(1, snake.length - 1);
        const segSize = cellSize * (i === snake.length - 1 ? 0.96 : 0.88);
        let rcol = 28, gcol = Math.floor(120 + (80 * (1 - t))), bcol = 36;
        if (document.documentElement.classList.contains("dark")) {
          rcol = 180; gcol = Math.floor(240 - 40 * t); bcol = 210;
        }
        ctx.fillStyle = `rgb(${rcol},${gcol},${bcol})`;
        roundRect(ctx, px + (cellSize - segSize) / 2, py + (cellSize - segSize) / 2, segSize, segSize, segSize * 0.18, true);
        if (i === snake.length - 1) {
          ctx.fillStyle = document.documentElement.classList.contains("dark") ? "rgba(0,0,0,0.95)" : "rgba(255,255,255,0.96)";
          const eyeW = Math.max(1, cellSize * 0.058);
          const ex = px + segSize * 0.34, ey = py + segSize * 0.32;
          ctx.fillRect(ex, ey, eyeW, eyeW);
          ctx.fillRect(ex + segSize * 0.18, ey, eyeW, eyeW);
        }
      }
    } else {
      for (let i = 0; i < snake.length; i++) {
        const p = snake[i];
        const px = offsetX + p.x * cellSize + sx, py = offsetY + p.y * cellSize + sy;
        const segSize = cellSize * 0.9;
        ctx.fillStyle = "#2f6b24";
        roundRect(ctx, px + (cellSize - segSize) / 2, py + (cellSize - segSize) / 2, segSize, segSize, segSize * 0.18, true);
      }
    }
    // Particles
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      const age = (performance.now() - p.born) / p.life;
      const alpha = Math.max(0, 1 - age);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color === "gold" ? "#ffd875" : "#ff8a8a";
      ctx.beginPath();
      ctx.ellipse(p.x + sx, p.y + sy, p.size * (1 - age), p.size * (1 - age), 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // Border
    ctx.strokeStyle = "rgba(0,0,0,0.14)";
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX + sx, offsetY + sy, boardW, boardH);
  }

  // --- Main Loop ---
  let raf = null;
  function mainLoop(now) {
    try {
      if (!lastTick) lastTick = now;
      const dt = now - lastTick;
      lastTick = now;
      accumulated += dt;
      const interval = moveInterval;
      while (running && accumulated >= interval) {
        gameTick();
        accumulated -= interval;
      }
      const frac = Math.min(1, accumulated / interval);
      updateParticles(dt);
      const head = snake[snake.length - 1];
      if (head) pushTrail(head.x, head.y);
      shake.x *= 0.86; shake.y *= 0.86;
      draw(now, frac);
    } catch (err) { }
    raf = requestAnimationFrame(mainLoop);
  }
  setupCanvas();
  raf = requestAnimationFrame(mainLoop);

  // --- Input Handling ---
  function setDirection(dx, dy) {
    const nd = { x: dx, y: dy };
    const head = snake[snake.length - 1];
    const neck = snake.length > 1 ? snake[snake.length - 2] : null;
    if (neck && neck.x === head.x + nd.x && neck.y === head.y + nd.y) return;
    nextDir = nd;
  }

  window.addEventListener("keydown", e => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d", "W", "A", "S", "D"].indexOf(e.key) === -1) return;
    e.preventDefault();
    if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") setDirection(0, -1);
    if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") setDirection(0, 1);
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") setDirection(-1, 0);
    if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") setDirection(1, 0);
  });

  // Touch controls
  let touchStart = null, touchLast = null;
  const SWIPE_THRESHOLD = 12;
  canvas.addEventListener("touchstart", ev => {
    if (ev.touches && ev.touches.length === 1) {
      const t = ev.touches[0];
      touchStart = { x: t.clientX, y: t.clientY, time: Date.now() };
      touchLast = { x: t.clientX, y: t.clientY };
    }
    ev.preventDefault();
  }, { passive: false });
  canvas.addEventListener("touchmove", ev => {
    if (ev.touches && ev.touches.length === 1 && touchStart) {
      const t = ev.touches[0];
      touchLast = { x: t.clientX, y: t.clientY };
    }
    ev.preventDefault();
  }, { passive: false });
  canvas.addEventListener("touchend", ev => {
    if (!touchStart) return;
    const end = touchLast || touchStart;
    const dx = end.x - touchStart.x, dy = end.y - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (Math.max(adx, ady) >= SWIPE_THRESHOLD) {
      if (adx > ady) setDirection(dx > 0 ? 1 : -1, 0);
      else setDirection(0, dy > 0 ? 1 : -1);
    }
    touchStart = null; touchLast = null;
    ev.preventDefault();
  }, { passive: false });

  // --- UI Events ---
  playBtn.addEventListener("click", startGame);
  retryBtn.addEventListener("click", startGame);
  menuBtn.addEventListener("click", () => {
    overlay.style.display = "flex";
    settingsPanel.style.display = "none";
    gameOverEl.style.display = "none";
    running = false;
    menuCard.classList.remove("exit");
  });
  pauseBtn.addEventListener("click", () => {
    running = !running;
    pauseBtn.textContent = running ? "Pause" : "Resume";
  });
  settingsBtn.addEventListener("click", () => {
    settingsPanel.style.display = settingsPanel.style.display === "block" ? "none" : "block";
  });
  wrapBtn.addEventListener("click", () => {
    wrap = !wrap;
    wrapBtn.dataset.wrap = String(wrap);
    wrapBtn.textContent = `Wrap: ${wrap ? "ON" : "OFF"}`;
  });
  shuffleBtn.addEventListener("click", () => {
    const sizes = [24, 20, 16], speeds = [0, 1, 2], themes = ["dark", "light"];
    const s = sizes[Math.floor(Math.random() * sizes.length)];
    const sp = speeds[Math.floor(Math.random() * speeds.length)];
    const th = themes[Math.floor(Math.random() * themes.length)];
    applySize(s); applySpeed(sp); applyTheme(th);
  });
  speedPicker.addEventListener("click", e => {
    const chip = e.target.closest(".chip");
    if (!chip) return;
    const idx = Number(chip.dataset.speed);
    applySpeed(idx);
  });
  sizePicker.addEventListener("click", e => {
    const chip = e.target.closest(".chip");
    if (!chip) return;
    const size = Number(chip.dataset.size);
    applySize(size);
  });
  themePicker.addEventListener("click", e => {
    const chip = e.target.closest(".chip");
    if (!chip) return;
    applyTheme(chip.dataset.theme);
  });

  function applySpeed(idx) {
    [...speedPicker.querySelectorAll(".chip")].forEach(c => c.classList.remove("active"));
    const active = speedPicker.querySelector(`.chip[data-speed="${idx}"]`);
    if (active) active.classList.add("active");
    speedLevel = idx;
    movesPerSecond = speedMap[speedLevel];
    moveInterval = 1000 / movesPerSecond;
  }
  function applySize(sizeCols) {
    [...sizePicker.querySelectorAll(".chip")].forEach(c => c.classList.remove("active"));
    const active = sizePicker.querySelector(`.chip[data-size="${sizeCols}"]`);
    if (active) active.classList.add("active");
    cols = sizeCols;
    setupCanvas();
    if (running) startGame();
  }
  function applyTheme(th) {
    [...themePicker.querySelectorAll(".chip")].forEach(c => c.classList.remove("active"));
    const active = themePicker.querySelector(`.chip[data-theme="${th}"]`);
    if (active) active.classList.add("active");
    if (th === "dark") {
      document.documentElement.classList.add("dark");
      themeToggle.setAttribute("aria-pressed", "true");
    } else {
      document.documentElement.classList.remove("dark");
      themeToggle.setAttribute("aria-pressed", "false");
    }
  }

  // --- Initialization ---
  (function initPickers() {
    const activeSpeed = speedPicker.querySelector(".chip.active");
    if (activeSpeed) applySpeed(Number(activeSpeed.dataset.speed));
    const activeSize = sizePicker.querySelector(".chip.active");
    if (activeSize) applySize(Number(activeSize.dataset.size));
    const activeTheme = themePicker.querySelector(".chip.active");
    if (activeTheme) applyTheme(activeTheme.dataset.theme);
  })();

  function applySystemTheme() {
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    if (prefersDark) {
      document.documentElement.classList.add("dark");
      themeToggle.setAttribute("aria-pressed", "true");
    } else {
      document.documentElement.classList.remove("dark");
      themeToggle.setAttribute("aria-pressed", "false");
    }
  }
  applySystemTheme();
  window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", applySystemTheme);
  themeToggle.addEventListener("click", () => {
    if (document.documentElement.classList.contains("dark")) {
      document.documentElement.classList.remove("dark");
      themeToggle.setAttribute("aria-pressed", "false");
    } else {
      document.documentElement.classList.add("dark");
      themeToggle.setAttribute("aria-pressed", "true");
    }
  });

  window.addEventListener("resize", () => {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    setupCanvas();
  });

  if (!apple) placeApple();
  playBtn.focus();
  window._snake = { startGame, applySize, applySpeed, applyTheme };
})();
</script>
</body>
</html>
